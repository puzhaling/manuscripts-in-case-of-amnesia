A rule does not have to be defined "all at once"

Wildcard expansion is performed by make when the pattern appears as a target or
prerequisite. In the command list, the expansion if performed by the subshell

Any target can be declared phony by including it as a prerequisite of .PHONY

Makefiles are written top-down but the commands are executed by make bottom-up

Phony target are completed before any prerequisite is updated

Many special variables defined automatically by make

Automatic variables are set by make after a rule is matched, so they are only
available in the command script of a rule

Unless you direct it otherwise, make will look only in the current directory for
its targets and prerequisites

VPATH variable consists of a list of directories to search when make needs a
file

The build in rules are all instances of pattern rules

The built-in rules can be customized by changing the values of the variables in
the command scripts

`make --print-data-base`

In pattern rules percent symbol means any number of any character (can occur
only once)

A static pattern rule is one that applies only to a specific list of targets

Suffix rules are the original (and obsolete) way of defining implicit rules

An implicit rule is either a pattern rule or a suffix rule

The built-in implicit rules are applied whenever a target is being considered
and there is no explicit rule to update it

The files generated by chaining rules are called intermediate files and are
treated specially by make

preprocessor options (CPPFLAGS)

Variables set on the command line override all other assignments to the variable

A special target is a built-in phony target used to change make's default
behavior

gcc's -M option generates dependencies for a source file

GNU make includes special features to support both the creation of libraries and
their use in linking programs

One of the primary goals of make is to use the processor efficiently by updating
only those files that are out of date

In GNU make, a member of an archive can be referenced using the notation:
	libgraphics.a(bitblt.o): bitblt.o
		----***----

When libraries appear as prerequisites, they can be referenced using either a
standard filename or with the -l syntax

When the -l form is used in a prerequisite, make will search for the library
(prefering a shared library) and substitute its value, as an absolute path, into
the $^ and $? variables

The built-in implicit rules are applied whenever a target is being considered
and there is no explicit rule to update it. So using an implicit rule is easy:
simply do not specify a command script when adding your target to the makefile

The linker will search libraries in the order in which they are listed on the
command line and never goes back

Double colon rules are an obscure feature that allows the same target to be
updated with different commands depending on which set of prerequisites are
newer than the target

Variables are case-sensitive

Variables representing constants a user might want to customize on the command
line or in the environment are written in all uppercase, by conv. Words are
separated by underscores. Variables that appear only in the makefile are all
lowecase with words separated with underscores

Trailing spaces are not trimmed in the variable value

Variables can also store user-defined commands sequences

There are two types of variables: simply expanded variables and recursively
expanded variables

Assignment operators: :=,=,?=,+=

A macro is just another way of defining variable in make, and one that can
contain embedded newlines

Command lines prefixed with an @ character are not echoed by make when the
command is executed

As a general rule, always define variables and macros before they are used

Before executing any command, it takes a "snapshot" of all calls

If we want to redefine a single variable for just a single rule or pattern,
make provides target-specific variables. These are
variable definitions attached to a target that are valid only during the process
ing of
that target and any of its prerequisites. Pattern-specific variables are
similar, only they are specified in a pattern rule.

The variable assignment is not actually performed until the processing of the
target begins (second phase)

All the variables from your environment are automatically defined as make
variables when make starts

A makefile should be able to run with a minimum of support from the developer's
environment

If the conditional directives had a leading tab, they would be misidentified as
commands and passes to the subshell

When make encounters an include directive, it expands the wildcards and variable
references, then tries to read the include file

GNU make supports both built-in and user-defined functions

Variables and macros can be passed arguments so that each expansion can be
different. The parameters of the macro are referenced within the body of the
macro definition with $1, $2, etc.

Only built-in functions can be called directly, user defined must be an argument
to call macro

Macros are just variables where embedded newlines are allowed

Expressions are code snippets that compute a value based on other values

For arithmetic and bit operations,
the type of the result is a type that reconciles the types of a and b

There are no make functions that understand numbers, only strings

Macro languages work by tranforming source test into output text through
defining and expanding macros

Automatic variables are universally written without paranthesis even in the GNU
make manual. However, the make manual uses paranthesis for virtually all other
variables, even single character variables, and strongly urges users to follow
suit

The argument to `eval` is first scanned for variables and expanded (as all
arguments to all functions are)

A macro (at top parsing level) that expands to multiple lines is illegal and
results in syntax error

We can resolve this problem by explicitly deferring the expansion of the
computed variables until the three variables are defined

Functions can be made more reusable by adding `hooks` to them. A `hook` is a
function reference that can be redefined by a user to perform their own custom
tasks during a standard operation

Commands are essentially one-line shell scripts. In effect, make grabs each line
and passes it to a subshell for execution

make's shell is controlled by the make variable SHELL but it is not inherited by
the environment

/ - continuation character

A command can be modified by several prefixes

With `!` symbol you can simply negate the exit status of the program (bash
specific)

When make needs to pass a command line to a subshell, it uses /bin/sh by
default

bash is a superset of sh

bash is a standard shell on GNU/Linux

"Don't hassle with writing portable makefiles, use a portable make instead!"

Commands executed by make inherit their processing environment from make itself

The cwd for an executed command is the working directory of the parent make

Command script processing occurs in four steps: read the code, expand variables,
evaluate make expressions, and execute commands

When working with large projects, you occasionally bump up against limitations
in the length of commands make tries to execute

make has no built-in limits to constrain us

Recursive make is a common technique for handling component-wise builds

The motivation behind recursive make is simple: make works very well within a
single directory (or small set) but becomes more complex when the number of
directories grows. So, we can use make to build a large project by writing a
simple, self-contained makefile for each directory, then exec them all
individually

The variable MAKE should always be used to invoke make within a makefile

The perfect recursive make impl would behave as if the many makefiles in the
system are a single makefile

To do the right thing, make automatically labels any line containing MAKE with
the + modifier, meaning make runs the sub-make regardless of the --touch option

Variable assignments from the command line are stored in the MAKEFLAGS variable
along with command-line options


