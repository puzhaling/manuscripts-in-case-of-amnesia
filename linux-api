Каталог - это особый файл, чье содержимое принимает форму таблицы из имен файлов в совокупности с указателями на соответствующие файлы. Эта связка из имени файла и указателя на него называется ссылкой.  Подобно обычной ссылке, символьная ссылка предоставляет альтернативное имя для файла. Но, в отличие от обычной ссылки, представляющей собой в списке каталога запись вида "имя файла + указатель", символьная ссылка - это специально помеченный файл, содержащий имя другого файла Каждый файл в файловой системе Линукс начинается с единственной жесткой ссылки (hard link)

Экранирование - это специальное помечение символа, для предотвращения его интерпретации той или иной среды

Процесс наследует свой текущий рабочий каталог от родительского процесса (у каждого процесса есть свой текущий рабочий каталог - т.е текущее местоположение процесса в иерархии одного каталога) 

Системные вызовы ввода вывода ссылаются на открытый файл с использованием файлового дескриптора

Функции stdio наслаиваются поверх системных вызовов ввода вывода

Ядро создает дочерний процесс путем изготовления дубликата родительского процесса. Дочерний процесс наследует копии родительских сегментов данных, стека и кучи, которые затем могут изменяться независимо от своих родительских копий. (Текс программы размещается в области памяти с пометкой "только для чтения" и совместно используется двумя процессами)

Процесс может быть завершен двумя способами: запросом своего собственного завершения с использованием системного вызова _exit() (или родственной ему библиотечной функции exit())  или путем его уничтожения с помощью сигнала. В любом случае процесс выдает код завершения, который может быть проверен родительским процессом с использованием системного вызова wait().

При загрузке системы ядро создает особый процесс, который называется init, "родитель всех процессов". Все процессы в системы создаются (используя fork()) либо процессом init, либо одним из его потомков. Этот процесс всегда имеет PID 1 и запускается с правами доступа суперпользователя. Он бессмертен и завершается только при завершении работы системы

У каждого процесса имеется список переменных среды, являющийся набором переменных среды, которй содержится в памяти пользовательского пространства процесса.

Используя системный вызов setrlimit(), процесс может установить верхний предел своего потребления различных ресурсов. Когда с помощью fork() создается новый процесс, он наследует копии настроек ограничений ресурсов от своего родительского процесса. Ограничение русурсов оболочки могут быть отрегулированы с использованием команды ulimit().

Линукс предоставляет обширный набор механизмов межпроцессного взаимодействия:
- сигналы
- конвейеры
- сокеты
- файловая блокировка
- очереди сообщений
- семафоры
- совместно используемая память

Широкое разнообразие IPC-механизмов в системах UNIX с иногда перекрываемыми функциональными возможностями частично объясняется их различием в отдельных вариантах UNIX-систем и требованиями со стороны различных стандартов.

Потоки можно представить себе в качестве набора процессов, совместно использующих одну и ту же виртуальную память, а так же ряд других атрибутов. Каждый поток выполняет один и тот же программный код и совместно с другими потоками использует одну и ту же область данных и кучу. Но каждый поток имеет свой собственный стек.

Основным преимуществом использования потоков является упрощение обмена данными между сотрудничающими потоками.

Время процесса, также называемое временем центрального процессора, которое является общим количеством времени центрального процессора, использованным процессом с момента старта. Время ЦП далее делится на системное время центрального процессора, то есть время, потраченное на выполнение кода в режиме ядра (например, на выполнение системных вызовов и работу других служб ядра от имени процесса), и пользовательское время центрального процессора, потраченное на выполнение кода в пользовательском режиме (например, на выполнение обычного программного кода). Команда time выводит реальное время, системное и пользовательское время центрального процессора, потраченное на выполнение процессов в конвейере.

Системный вызов представляет собой управляемую точку входа в ядро, позволяющую процессу запрашивать у ядра осуществление некоторых действий в интересах процесса.

В Linux подпрограммы обслуживания системных вызовов (обработчики системных вызовов) имеют имя sys_xyz(), где xyz() является соответствующим системным вызовом.

Зачастую библиотечные функции разработаны для предоставления более удобного интерфейса вызова по сравнению с тем, что имеется у исходного системного вызова.

Стандартная библиотека языка С, реализованная в рамках проекта GNU - glibc

Статические библиотеки имеют расширение a, динамические - so.

При неудачном завершении системного вызова для глобальной целочисленной переменной errno устанавливается положительное значение, позволяющее идентифицировать конкретную ошибку. Значение errno имеет смысл только тогда, когда системный вызов или функция возвращает признак ошибки. В случае ошибки некоторые библиотечные функции заносят в errno положительное значение, но никогда не обнуляют его. Нулю errno равно нулю только при запуске программы.

SUS - Single Unix Specification

При проверке на ошибку нужно всегда сперва проверить, не вернула ли функция значение, свидетельствующие о возникновении ошибки, и только потом исследовать errno для определения причины ошибки.

Некоторые функции в состоянии установить errno ненулевое значение как показатель успешного завершения. В таком случае, перед таким системным вызовом нужно установить значение errno = 0 и проверить ее значение после вызова.

Общая линия поведения после неудачного системного вызова заключается в выводе сообщения об ошибке на основе значения переменной errno. Для это цели предоставляются библиотечные функции perror() и strerror().

ключ команды (флаг)

Поведение API системных вызовов и вывозов библиотечных функций регулируется различными стандартами. Одни стандарты определены организациями стандартизации, такими как Open Group (Single UNIX Specification), а другие - двумя исторически важными реализациями UNIX: BSD и System V. При создании портируемого приложения могут понадобиться различные заголовочные файлы для предоставления только тех значений, которые отвечают конкретному стандарту. Для этого определены несколько макросов проверки возможностей.

Кроме использования стандартных типов данных языка С вам предоставляются различные типы данных реализации (идентификаторы процессов, пользователей и т.д). Они позволяют портируемым образом хранить информацию между системами UNIX. Для этого в SUSv3 указываются различные стандартные типы системных данных, а к реализации предъявляются требования по надлежащему определению и использованию этих типов. У большинства стандартных системных данных имена заканчиваются на _t.

Приложение должно использовать эти определения типов, чтобы портируемым образом объявить используемые им переменные.

При компиляции приложения можно задавать различные макросы проверки возможностей. Они управляют определениями, которые предоставляются заголовочными файлами.

Все системные вызовы для выполнения ввода-вывода совершаются в отношениию открытых файлов с использованием дескриптора файла, представленного неотрицательным целым числом. Дескрипторы файлов применяются для обращения ко всем типам открытых файлов, включая конвейеры, ФИФО-устройства, сокеты, терминалы, аппаратные устройства и обычные файлы. Каждый процесс имеет свой собственный набор дескрипторов файлов.

Если в командной строке указано перенаправление ввода-вывода, то оболочка перед запуском программы обеспечивает соответствующие изменения дескрипторов файлов.

Одна из отличительных особенностей модели ввода-вывода UNIX состоит в универсальности ввода-вывода. Это означает, что одни и те же четыре системных вызова - open(), read(), write(), close() - применяются для выполнения ввода-вывода во всех типах файлов.

В SUSv3 определяется, что при успешном завершении системного вызовы open() гарантируется, что процессу будет выделен наименьший неиспользуемый дескриптор файла.

Начиная с версия ядра 2.6.22, для получения информации о дескрипторах файлов любого имеющегося в системе процесса могут быть прочитаны файлы в каталоге /proc/PID/fdinfo, которые есть только в Linux.

При возникновении ошибки при попытке открытия файла системный вызов open() возвращает -1, а в errno идентифицируется причина ошибки.

В ранних реализациях UNIX у open() было только два аргумента, и этот вызов нельзя было использовать для создания нового файла. Вместо него для создания и открытия нового файла использовался системный вызов creat(). 

При выполнении ввода-вывода в отношении дискового файла успешный выход из write() не гарантирует перемещение данные на диск, поскольку ядро занимается буферизацией дискового ввода-вывода, чтобы сократить объем работы с диском и ускорить выполнение системного вызова write().

Системный вызов close() закрывает открытый дескриптор файла, высвобождая его для последующего повторного использование процессом. 

Для каждого открытого файла в ядре записывается файловое смещение, которое также итогда называют смещением чтения-записи или указателем. Оно обозначает место в файле, откуда будет стартовать работа следующего системного вызова read() или write(). Файловое смещение выражается в виде обычной байтовой позиции относительно начала файла. Первый байт файла расположен со смещением 0.

При успешном выполнении lseek() возвращается значение нового файлового смещения.

Вызов lseek() просто устанавливает значение для записи ядра, содержащей файловое смещение и связанной с дескриптором файла. Никакого физического доступа к устройству при этом не происходит.

Системный вызов ioctl() - механизм общего назначения для выполнения операций в отношении файлов и устройств, выходящих за пределы универсальной модели ввода-вывода.

Концепция атомарности подразумевает, что действия в рамках системного вызова выполняются в виде единого непрерывного шага - это неотъемлемое требования для корректной работы многих системных вызовов.

Все системные вызовы выполняются атомарно. Это означает, что ядро гарантирует завершение всех этапов системного вызова в рамках одной операции, которая не прерывается других процессом или потоком.

Состояние гонки - состязательная ситуация.

Проводимая проверка существования файла, при наличии соответствующего флага O_EXCL, системным вызовом open() выполняется атомарно. 

Применение одного вызовы open() с указанием флагов O_CREAT и O_EXCL предотвращает гонку данных гарантируя, что этапы проверки и создания выполняются как единая атомарная (то есть непрерывная) операция.

Флаг O_APPEND системного вызова open() гарантирует, что смещение на следующий байт за конец файла и операции записи будут происходить атомарно.

126 ??? Про атомарность не пойму здесь

Операционная система не отслеживает, что разные файловые дескрипторы могут указывать на один и тот же файл, поэтому обеспечивает атомарность работы только с одним и тем же дескриптором. В случае, если несколько дескрипторов ссылаются на один и тот же файл, атомарность не гарантируется.

Каждый файловый дескриптор имеет свое значение смещения.

Системный вызов fcntl() может выполнять операции управления, используя дескриптор открытого файла.

Ядро использует значение аргумента cmd для определения типа данных (если таковой будет), который следует ожидать для этого аргумента.

Один из примеров использования fcntl() - извлечение или изменение флагов режима доступа и состояния открытого файла (flags из open()).

Чтобы изменить флаги состояния открытого файла, сначала с помощью вызовы fcntl() извлекаются копии существующих флагов, затем изменяются нужные разряды и, наконец, делается еще один вызов fcntl() для обновления флагов. 

Есть весьма полезная возможность иметь сразу несколько дескрипторов, ссылающихся на один и тот же открытый файл. Эти файловые дескрипторы могут быть открыты в одном и том же или в разных процессах.

Для каждого процесса ядро поддерживает таблицу дескрипторов открытых файлов.

Также ядро поддерживает общесистемную таблицу дескрипторов открытых файлов и таблицу индексных дескрипторов файловой системы.

!!!! "И наконец, можно увидеть, что дескриптор 0 процесса А и дескриптор 3 процесса Б ссылаются на различные дескрипторы открытых файлов, но эти дескрипции ссылаются на одну и ту же запись в таблице индексных дескрипторов (имеют различные записи в общесистемной таблице дескрипторов и следовательно - смещение файла), то есть на один и тот же файла. Дело в том, что каждый процесс независимо вызвал open() для одного и того же файла. Похожая ситуация может возникнуть, если один и тот же процесс дважды откроет один и тот же файл.

Вызов duр на основании аргумента oldfd открывает файловый дескриптор, возвращая новый дескриптор, ссылающийся на ту же самую дескрипцию открытого файла.
(гарантированно новый дескриптор будет наименьшим доступным)

Дублировать файловые дескрипторы можно и с помощью СВ fcntl() с помощью операции F_DUPFD.

Продублированные файловые дескрипторы совместно используют одно и то же значение файлового смещения и одни и те же флаги состояния в своих совместно используемых дескрипциях открытых файлов. 

Системные вызовы pread() и pwrite() работают практитески так же, как read() и write(), за исключением того, что файловый ввод-вывод осуществляется с места, указанного значением offset, а не с текущего файлового смещения. Эти вызовы не изменяют файлового смещения. Применяются для устранения состояния гонки.

Системные вызовы readv() и writev() выполняют фрагментированный ввод/вывод соответственно. Оба выполняются атомарно.

В Linux 2.6.30 также были добавлены два новых системных вызова, сочетающих в себе возможности фрагментированного ввода-вывода с возможностью выполнения ввода-вывода по указанному смещению: preadv() и pwritev().

Системные вызовы truncate() и ftruncate устанавливают для файла размер, соответствующий значению, указанному в аргументе length.

Так как на 32 разрядных архитектурах максимальный размер файла равен 2гб, а уже на тот момент емкость дисковых накопителей давным давно преодолела это ограничение, перед реализациями UNIX встала необходимость работы с файлами, превышающими этот размер. Для этого был собран саммит LFS, который принял решение о добавлении переходного расширения для спецификации Single UNIX Specification. 

Расширение предоставляет аналоги 32 разрядных системных вызовов для работы с файлами, но с суффиксом "64".

Вызов open64 эквивалентен указанию флага O_LARGEFILE при вызове open(). Попытки. Попытки открыть файл, размер которого превышает 2 гб, с помощью open без этого флага приведут к возвращению ошибки.

Каждому процессу ядро предоставляет специальный виртуальный каталог /dev/fd.Он содержит имена файлов вида /dev/fd/n, где n является номером, соответствующим одному из дескрипторов файла, открытого для этого процесса.

В Linux открытие одного из файлов в /dev/fd эквивалентно повторному открытию исходного файла. Иначе говоря, новый файловый дескриптор связан с новым описанием открытого файла (и, следовательно, имеет различные флаги состояния файла и смещение файла).

Фактически /dev/fd является символьной ссылкой на характерный для Linux каталог /proс/self/fd (сам на себя). Он представляет собой частный случай свойственных для Linux каталогов /proc/PID/fd, в каждом из которых хранятся символьные ссылки, соответствующие всем файлам, содержащимся процессом в открытом состоянии.

Некоторые программы нуждаются в создании временных файлов, используемых только при выполнении программы, а при завершении программы такие файлы должны быть удалены.

Функция mkstemp создает уникальные имена файлов на основе шаблона, предоставляемого вызывающим процессом и открывает файл, возвращая файловый дескриптор. Созданный этой функцией файл является файлом с правами на чтение и запись для владельца файла (нет прав для других пользователей) и открывает его с флагом O_EXCL, гарантируя вызывающему процессу эксклюзивный доступ к файлу.

Для создания уникальных имен файлов могут также применяться функции tmpnam(), tempnam() и mktemp(). Но их использования следует избегать, поскольку они могут создавать в приложении бреши в системе безопасности.

Функция tmpfile создает временный файл с уникальным именем, открытый для чтения и записи.

Процесс является экземпляром выполняемой программы.

Переформулировка. Процесс является абстрактной сущность, которая установлена ядром и которой для выполнения программы выделяются системные сущности.

Программа представляет собой файл, содержащий различную информацию о том, как сконструировать процесс в ходе выполнения.

У каждого процесса есть идентификатор (PID), положительное целое число, уникальным образом идентифицирующее процесс в системе. Идентификаторы процессов используются и возвращаются различными системными вызовами. 

Идентификатор вызывающего процесса возвращается системным вызовом getpid().

У каждого процесса имеется родительский процесс, то есть тот процесс, который его создал. Определить идентификатор родительского процесса вызывающий процесс может с помощью системного вызова getppid().

По сути, имеющийся у каждого процесса атрибут идентификатора родительского процесса представляет древовидную структуру связи всех процессов в системе. Родитель каждого процесса имеет собственного родителя и т.д, возвращаясь в конечном итоге к процессу 1, init, предку всех процессов. Просмотр этого родового дерева - pstree.

Если дочерний процесс становится "сиротой" из за завершения работы породившего его родительского процесса, то он оказывается приемышем у процесса init.

Память, выделяемая каждому процессу, состоит из нескольких частей, которые обычно называют сегментами. 

Сегмент инициализированных данных - хранит глобальные и статические переменные, инициализированные явным образом. Значения этих переменных считываются из исполняемого файла при загрузке программы в память.

Сегмент неинициализированных данных - содержит глобальные и статические переменные, не иниц. явным образом. Перед запуском программы система инициализирует всю память в этом сегменте значением 0.

В стековом фрейме хранятся локальные переменные функции (автоматические), аргументы и возвращаемое значение.

Команда size выводит размеры текстового сегмента, сегмента инициализированных и неинициализированных данных двоичной формы исполняемой программы.

При использовании статической памяти функция становится нереентабельной (не допускается повторный вызов функции до завершения ее работы).

Хотя это и не описано в SUSv3, среда программы на языке Си во многих реализациях UNIX (включая Linux) предоставляет три глобальных идентификатора: etext, edata, end. Они могут использоваться из программы для получения адресов следующего байта соответственно за концом из текста программы, за концом сегмента инициализированных данных и за концом сегмента неинициализированных данных.

Цель управления виртуальной памятью заключается в создании условий для эффективного использования как центрального процессора, так и оперативной (физической) памяти путем применения свойства локальности ссылок, присущего многих программам.

В результате локальности ссылок появляется возможность выполнять программу, располагая в оперативной памяти лишь часть ее адресного пространства.

Структура виртуальной памяти подразумевая разбиение памяти, используемой каждой программой, на небольшие блоки фиксированного размера, называемые страницами. Соответственно, оперативная память делится на блоки страничных кадров (фреймов) одинакового размера. В любой отдельно взятый момент времени в страничных кадрах физической памяти требуется наличие только некоторых страниц программы. Эти страницы формируют так называемый резидентный набор. Копии неиспользуемых страниц программы размещаются в области подкачки.

Для поддержки этой организации ядро ведет для каждого процесса таблицу страниц.

Диапазон допустимых для процесса виртуальных адресов за время его жизненного цикла может измениться по мере того, как ядро будет выделять для процесса и высвобождать страницы (и записи в таблице страниц).

Текущая вершина стека отслеживается в специальной предназначенном для этого регистре - указателе стека.

Как только вызывается функция, стеку выделяется еще один фрейм.

Иногда применяется выражения "пользовательский стек" - это позволяет отличить рассматриваемый здесь стек от стека ядра. Стек ядра - поддерживаемая в памяти ядра область, выделяемая каждому процессу, которая используется в качестве стека для выполнения функций, вызываемых внутри системного вызова в ходе его работы. (Ядро не может применять для этой цели пользовательский стек, поскольку тот размещается в незащищенной пользовательской памяти.)

У каждой программы на языке Си должна быть функция по имени main(), с которой и начинается выполнение программы. 

Список указателей в argv завершается указателем со значением NULL. (argv[argc] = NULL)

char **p;
for (p = argv; *p != NULL; ++p)
  puts(*p);

У каждого процесса есть связанный с ним строковый массив, который называется списком переменных среды (окружения) или просто средой (окружением). Каждая из его строк является определением вида имя=значение. 

Когда создается новый процесс, он наследует копию среды своего родителя (это может использоваться как одностороний, однократный способ межпроцессного взаимодействия).

Переменные среды часто используются оболочкой. Помещая значения в свою собственную среду, оболочка может обеспечить передачу этих значений процессам, создаваемым ее для выполнения пользовательских команд.

Некоторые библиотечные функции позволяют изменять свое поведение путем установки переменных среды.

bash:
SHELL=/bin/bash Создание переменной оболочки
export SHELL    Помещение переменной в среду процесса оболочки
unset  SHELL    Удаление переменной среды

Текущий список переменных среды выводится на экран командой printenv.

Список переменных среды любого процесса можно изучить, обратившись к характерному для Linux /proc/PID/environ.

Из программы на языке Си список переменных среды может быть доступен с помощью глобальной переменной char **environ. Так же, как и argv, он заканчивается нулевым указателем. 

Альтернативный метод обращения к списку переменных среды заключается в объявлении для функции main() третьего аргумента:
int main(int argc, char *argv[], char *envp[])

Хотя это свойство широко реализовано в системах UNIX, его использования следует избегать, поскольку, вдобавок к ограничениям по областям видимости, оно не указано в спецификации SUSv3.

Отдельные значения из среды процесса извлекаются с помощью функции getenv().

Функция putenv добавляет новую переменную к среде вызывающего ее процесса или изменяет значение существующей переменной.

Функция setenv является альтернативой putenv, предназначенной для добавления переменной к среде. 

Функция unsetenv удаляет из среды переменную, идентифицируемую аргументом name.

Эти две функции берут начало из BSD.

Среду можно удалить, присвоив переменной environ значение NULL. Именно такое действие и предпринимается в библиотечной функции clearenv().

В некоторых обстоятельствах использование setenv и clearenv может привести к утечкам памяти в программе. Из за того, что функция setenv выделяет буфер памяти, который затем составляет часть среды. Когда вызывается функция clearenv, она не высвобождает данный буфер (это невозможно, поскольку ей ничего не известно о его существовании)

Функции setjmp и longjmp используются для нелокального перехода. Термин нелокальный означает, что цель перехода находится где то за пределами той функции, которая выполняется в данный момент.

Вызов setjmp устанавливает цель для последующего перехода, выполняемого функцией longjmp. Этой целью является та самая точка в программе, откуда вызывается функция setjmp. С точки зрения программирования после longjmp это выглядит абсолютно так же, как будто мы только что вернулисьиз вызова setjmp во второй раз. Способ, позволяющий отличить второе возвращение от первого, основан на целочисленном значении, возвращаемым функцией setjmp. При первом вызове setjmp возвращает 0, а при последующем, фиктивном возвращении предоставляется то значение, которое указано в аргументе val при вызове функции longjmp.

Нелокальный переход происходит с раскруткой стека.

Используемый обеими функциями аргумент env предоставляет связующий элемент, позволяющий осуществить переход.

Внимание! Нельзя выполнять переход с помощью функции longjmp в функцию, из которой уже произошел возврат. Что longjmp пытается сделать со стеком? Она пытается раскрутить назад к фрейму, которого уже нет, что приводит в результате к хаосу.

Оптимизирующие компиляторы могут переопределить порядок следования инструкций в программе и сохранить конкретные переменные в регистрах центрального процессора, а не в оперативной памяти. Обычно такая оптимизация зависит от потока управления ходом выполнения программы, отражающего лексическую структуру программы. Поскольку операции перехода, выполняемые с помощью этих двух функций создаются и происходят в ходе выполнения программы, оптимизатор компилятора не может взять их в расчет в процессе своей работы. Более того, семантика некоторых реализаций двоичных интерфейсов приложений требует, чтобы функция longjmp восстанавливала копии регистров центрального процессора, сохраненные ранее при вызове функции setjmp. Это говорит о том, что в результате вызова longjmp в оптимизированных переменных могут оказаться неверные значения.

....Подобной реорганизации кода можно избежать, объявив переменные изменяемыми - volatile, что даст указание оптимизатору не оптимизировать их.

Поскольку различные компиляторы используют различные приемы оптимизации, в портируемых программах в тех функциях, которые вызывают setjmp, ключевое слово volatile должно указываться со всеми локальными переменными вышеупомянутых типов.

Динамическая память необходима для хранения структур данных, размер которых известен только во время выполнения программы.

Текущее ограничение кучи называется крайней точкой программы.

Работа функций malloc основана на работе двух системных вызовов: brk и sbrk.

Изменение размеров кучи (то есть выделение и высвобождение памяти) сводится лишь к тому, чтобы всего лишь объяснить ядру, где располагается крайняя точка программы. Изначально крайняя точка программы находится непосредственно сразу же за окончанием сегмента неинициализированных данных. Страницы физической памяти будут выделены ядром при первой же попытке процесса обратиться к адресам этих страниц.

Виртуальная память выделяется постранично.

Вызов sbrk приводит к изменению положения точки программы путем добавления к ней приращения increment. (В Linux sbrk является библиотечной и реализована в виде надстройки над функцией brk).

Блок памяти, возвращенный malloc, всегда выравнивается по байтовой границе, обеспечиващей эффективное обращение к данным любого типа языка С.

Функция free высвобождает блок памяти, указанный в ее аргументе ptr, который должен быть адресом, ранее возвращенным функцией malloc или одной из других функций выделения памяти в куче.

Фактически функция free не сдвигает вниз крайнюю точку программы, а вместо этого добавляет блок памяти к списку свободных блоков, которые будут снова использованы при дальнейших вызовах функции malloc.

Функция free из библиотеки glibc осуществляет вызов sbrk для снижения уровня крайней точки программы, только когда высвобождается блок на вершине кучи достаточно большой. (параметр конфигурации подразумевается под достаточностью).

Когда блок помещается в двухсвязный список свободных блоков, функция free использует для добавления блока к списку байты самого блока.

Функция calloc выделяет память для массива одинаковых элементов. В отличие от malloc, calloc инициализирует выделенную память нулевым значением.

Функция realloc используется для изменения размера (обычно увеличения) блока памяти, ранее выделенного одной из функций из пакета malloc.

Функции memalign и posix_memalign предназначены для выделения памяти, начиная с адреса, который будет кратен некоторой степени двойки, что может весь пригодиться для отдельных приложений.

Как и функции в пакете malloc, функция alloca выделяет память в динамическом режиме. Но вместо получения памяти в куче alloca получает память из стека путем увеличения размера стекового фрейма. Нам не нужно, а на самом деле мы не должны вызывать функцию free для высвобождения памяти, выделенной с помощью функции alloca. Точно так же невозможно использовать функцию realloc для изменения блока памяти выделенного с помощью alloca.

У каждого пользователя имеется уникальное имя для входа в систему и связанный с ним числовой идентификатор пользователя (UID). Пользователи могут состоять в одной или нескольких группах. У каждой группы также есть уникальное имя и идентификатор группы (GID). 

Основное предназначение пользовательских и групповых идентификаторов - определение принадлежности различных системных ресурсов и управления правами, предоставляемыми процессам по доступу к этим ресурсам. Например, каждый файл принадлежит конкретному пользователю и группе, а у каждого процесса есть несколько пользовательских и групповых идентификаторов, определяющих владельцев процесса и набор прав для доступа к файлу.

В системном файле паролей, /etc/passwd, содержится по одной строке для каждой имеющейся в системе учетной записи пользователя. 

Если поле пароля в /etc/passwd пустое, значит, для регистрации под этой учетной записью пароль не нужен (это правило действует даже при наличии теневых паролей)

UID суперпользователя = 0.

Идентификатор группы в файле /etc/passwd - это числовой идентификатор первой из групп, в которую входит пользователь. Дальнейшая принадлежность к группам этого пользователя определена в системной файле групп.

Исторически сложилось так, что в системах UNIX вся информация о пользователях, включая зашифрованные пароли, хранится в файле /etc/passwd. В связи с этим возникают проблемы безопасности (см. стр. 188 для подробностей). Теневой файл паролей, /etc/shadow, был разработан как средство противостояния таким атакам. Замысел заключается в том, что вся конфиденциальная информация о пользователе находится в открытом, доступном для чтения файле паролей, а зашифрованные пароли храняться в теневом файле паролей, доступном для чтения только программам с особыми привилегиями.

Теневые пароли в SUSv3 не определены. Кроме того, они предоставляются не всеми реализациями UNIX.

Пользователей для различных административных целей, в частности для управления доступом к файлам и другим системным ресурсам, полезно свести в группы.

Набор групп, к которым принадлежит пользователь, определен в виде сочетания поля идентификатора группы в записи пользователя в файле пароля и групп, под которыми этот пользователь перечисляется в файле групп. Это странное разбиение на два файла сложилось исторически. В ранних реализациях UNIX можно было одновременно входить только в одну группу. Исходная группа, в которую входил пользователь при входе в систему, определялась полем GID файла паролей и могла быть в нем изменена после использования команды newgrp. Эта команда требовала от пользователя предоставить пароль группы (при наличии такой защиты). В 4.2BSD было введено понятие одновременной принадлежности к нескольким группам, позже ставшее стандартом. Согласно этой схеме в файле групп имелся список принадлежности каждого пользователя к дополнительной группе.

Файл /etc/group содержит по одной строке для каждой группы в системе. 

gpasswd - редактирование пароля группы.

Функция crypt, которая может пригодиться для программ, нуждающихся в аутентификации пользователя, шифрует пароль точно так же, как и стандартная программа входа в систему.

Извлечение записей из файла паролей производится с помощью функций getpwnam и getpwuid.

Поле pw_gecos происходит из ранних реализаций UNIX, где в нем содержалась информация для связи с машиной, на которой запущена ОС GECOS. Хотя эта цель его применения давно устарела, имя поля осталось прежним, а само оно предназначено для записи информации о пользователей.

Обе эти функции возвращают указатель на статически выделенную структуру, которая перезаписывается при каждом вызове любой из этих функций (или getpwent).

У каждого процесса есть набор связанных с ним числовых идентификаторов пользователей (PID) и идентификаторов групп (GID). Иногда их называют идентификаторами процесса. В число этих идентификаторов входят:
    реальный (real) ID пользователя и группы
    действующий (effective) ID пользователя и группы
    сохраненный установленный ID пользователя (saved set-user-ID) и сохранен    ный установленный ID группы (saved set-group-ID)
    характерный для Linux пользовательский и групповой ID файловой системы
    дополнительные идентификаторы групп



В соответствии с положениями SUSv3, если нужная запись passwd не может быть найдена, функции getpwnam и getpwuid должны возвратить значение NULL, оставив значение errno в неизменном виде.

Записи из файла групп извлекаются с помощью функций getgrnam и getgrgid.

Поле gr_passwd структуры group в SUSv3 не указано, но доступно в большинстве реализаций UNIX.

Если функции не могут найти запись, соответствующую группе, они демонстрируют такие же варианты поведения, которые были рассмотрены для функций getpwnam и getpwuid.

Функции setpwent, getpwent, endpwent используются для выполнения последовательного сканирования записей в файле паролей.

При первом вызове функция автоматически открывает файл паролей. Когда работа с файлом завершена, для его закрытыя вызывается функция endpwent.

Следующие функции используются для извлечения отдельных записей из теневого файла паролей и сканирования всех записей в этом файле: getspnam, getspent, setspent, endspent (эти функции не указаны в SUSv3 и представлены не во всех реализациях UNIX). Скорей всего это связано с тем, что сами теневые пароли в SUSv3 не определены и не всеми реализациями UNIX они предоставляются.

Из соображений безопасности системы UNIX шифруют пароли, используя алгоритм одностороннего шифрования. Он гарантирует невозможность воссоздания исходного пароля из его зашифрованной формы. Поэтому единственный способ проверить верность проверяемого пароля - его шифрование с использованием того же метода, что позволяет увидеть, соответствует ли зашифрованный результат значению, сохраненному в файле /etc/shadow. Алгоритм шифрования заключен в функции crypt.

Для того, чтобы читать файл теневых пароль требуются полномочия суперпользовтеля или принадлежность к группе shadow.

Реальные идентфикаторы пользователя и группы идентифицируют пользователя и группу, которым принадлежит процесс. При входе в систему оболочка получает свои реальные ID пользователя и группы из третьего и четвертого полей записи в файле /etc/passwd. При создании нового процесса он наследует эти идентификаторы у своего родительского процесса.

В большинстве реализаций UNIX (для Linux см. расхождения в 9.5) действующие UID и GID в совокупности с дополнительными идентификаторами групп используются для определения полномочий, которыми наделен процесс, при его попытке выполнения различных операций (в частности, системных вызовов). Например, эти идентификаторы определяют полномочия, которыми процесс наделен при доступе к таким ресурсам, как файлы и объекты межпроцессного взаимодействия.

Процесс, чей действующий идентификатор пользователя имеет значение 0 (он принадлежит пользователю с именем root), имеет все полномочия суперпользователя. Такой процесс называют привилегированным. Некоторые системные вызовы могут быть выполнены только привилегированными процессами.

Программа с установленным идентификатором пользователя позволяет процессу получить полномочия, которые он обычно не получает, путем установки действующего ID пользователя на тоже значение, которое имеется у идентификатора пользователя (владельца) исполняемого файла.

У ИСПОЛНЯЕМОГО файла имеется два специальных бита полномочий: бит установленного идентификатора пользователя (set-user-ID) и бит установленного идентификатора группы (set-user-ID). Эти биты устанавливаются командой chmod. Непривилегированный пользователь может устанавливать эти биты для тех файлов, которыми он владеет, суперпользователь - для всех.

Когда для вывода списка полномочий программы, имеющей установленный бит set user ID или set group ID, используется команда ls -l, в нем буква x, которая обычно применяется для демонстрации установки полномочия на выполнение, заменяется буквой s.

Когда set user ID программа запускается (то есть загружается в память процесса с помощью команды exec), ядро устанавливаеь для действующего пользовательского ID точно такое же значение, что и у пользовательского ID исполняемого файла.

Изменение действующего пользовательского или группового ID таким способом дает процессу (а иными словами, пользователю, для которого выполняется программа) полномочия, которые он не имел бы при других обстоятельствах. Например, если исполняемый файл принадлежит пользователю по имени root и имеет установленный set user ID, то процесс при запуске программы обретает полномочия рута.

Программа su позволяет запускать оболочку под различными UID.

Сохраненный set-user-ID позволяет переключаться между привелегиями (сброс действующего uid до реального) и затем переключаться обратно (действующий uid на сохраненный).


Действительный UID и GID. Эти ID используются ядром для определения разрешений которые процесс получает во время попытки доступа к разделяемым ресурсам, таким как очереди сообщений, общая память и семафоры. В большинстве UNIX систем, эти ID также позволяют определить разрешения при попытки доступа к файлам. Однако, Linux использует пользовательские и групповые ID файловой системы для этой цели. (see credentials(7))

В Linux для определения полномочий при выполнении операций, связанных с файловой системой (открытие файла, изменение его собственника и модификация молномочий), применяются не действующие пользовательские и групповые ID, а пользовательские и групповые ID файловой системы.

Когда изменяется действующий пользовательский или групповой ID (либо посредством системного вызова, либо из за выполнения программы с полномочиями setuid или setguid), изменяется, получая такое же значение, и соответствующий идентификатор файловой системы. Поскольку идентфикаторы файловой системы следуют таким образом за действующими идентификаторами, это означает, что Linux при проверке привилегий и полномочий фактически ведет себя точно так же, как и любая другая реализация UNIX. Лишь когда используются два характерных для Linux системных вызова - setfsuid и setfsgid, поведение Linux отличается от поведения других реализаций UNIX, и ID файловой системы отличаются от соответствующих действующих идентификаторов.

Дополнительные групповые идентификаторы представляют собой набор дополнительных групп, которым принадлежит процесс. Новый процесс наследует эти идентфикаторы от своего родительского процесса. Оболочка входа в систему получает свои дополнительные идентификаторы групп из файла групп системы.

В качестве альтернативы применения системных вызовов для извлечения и модификации идентификаторов процессов, описанных в этой главе, идентификаторы любого процесса могут быть определены путем анализа строк Uid, Gid и Groups, предоставляемых Linux файлом proc/PID/status.

Системные вызовы getuid и getgid возвращают соответственно реальный пользовательский идентификатор и реальный идентификатор группы вызывающего процесса.Системные вызовы geteuid и getegid выполняют соответствующие задачи для действующих идентификаторов. Эти системные вызовы всегда завершаются успешно.

Привелегированный процесс - это один из процессов, чей действительный идентификатор пользователя имеет значение 0.

Системный вызов setuid изменяет действующий идентификатор пользователя, и, возможно, реальный ID пользователя и сохраненный установленный ID пользователя вызывающего процесса, присваивая значение, заданное его аргументом uid. Системный вызов setgid выполняет аналогичную задачу для соответствующих идентификаторов группы.

Непривилегированный процесс может вносить в свои действующие идентификаторы изменения с использованием seteuid и setegid. Их работа регулируется следующими правилами. 1. Непривилегированный процесс может изменять действующий идентификатор, присваивая ему только то значение, которое соответствует реальному или сохраненному установленному идентификатору. (Иными словами, для непривилегированного процесса функции seteuid и setegid произведут тот же эффект, что и функции setuid и setgid соответственно, ща исключением ранее упомянутых вопросов портируемости на BSD-системы.). 2. Привилегированный процесс может изменять действующий идентификатор, присваивая ему любое значение. Если привилегированный процесс применяет seteuid для изменения своего действующего пользовательского идентификатора на ненулевое значение, то он перестает быть привилегированным (но в состоянии вернуть себе полномочия в силу предыдущего правила.)

Таким образом, использование seteuid является предпочтительным методом для программ с полномочиями setuid и setgid с целью временного сброса и последующего восстановления полномочий.

Системный вызов setreuid позволяет вызывающему процессу независимо изменять значение его реального и действующего пользовательского идентификатора (setreuid для групп аналогично).

В Linux предоставляются два нестандартных системных вызова - getresuid и getresgid. Они позволяют извлечь реальный, действующий и сохраненный установленный идентификатор пользователя (группы) соответственно.

Системный вызов setresuid позволяет вызывающему процессу независимым образом изменять значения всех его трех пользовательских идентификаторов. Аналогичные задачи для групповых идентификаторов может выполнять системный вызов setresgid.

Вызовы setresuid и setresgid делают "все или ничего".

Все ранее рассмотренные системные вызовы, изменяющие действующие пользовательские или групповые идентификаторы процесса, также всегда изменяют и соответствующий идентификатор файловой системы. Чтобы изменить идентификаторы файловой системы независимо от действующих идентификаторов, следует применить два характерных только для Linux системных вызова: setfsuid и setfsgid.

Использование этих системных вызовов больше не имеет в Linux никакой практической необходимости, и его следует избегать в тех приложениях, которые разрабатываются с прицелом на портирование для работы в других реализациях UNIX.

Системный вызов getgroups записывает в массив, указанный в аргументе grouplist набор групп, в которые на данный момент входит вызывающий процесс.

Привилегрованный процесс может изменить свой набор дополнительных групповых идентификаторов, выполнив setgroups и initgroups.

При выполнении программы нас могут интересовать два вида времени.
1) Реальное время.
2) Время процесса.

Большинство компьютерных архитектур предусматривают наличие встроенных аппаратных часов, позволяющих ядру замерять реальное время и время процесса.

Календарное время. В зависимости от географического местоположения, внутри систем UNIX время представляется отмеренным в секундах от начала его отсчета (Epoch): от полуночи 1 января 1970 года. Примерно в это время начали свое существование системы UNIX. Календарное время сохраняется в переменных типа time_t, который относится к целочисленным типам, указанным в SUSv3.

Системный вызов gettimeofday возвращает календарное время в буфер, на который указывает значение аргумента tv. Хотя для поля tv_usec предусмотрена микросекундная точность, конкретная точность возвращаемого в нем значения определяется реализацией, зависящей от архитектуры системы. В современных системах x86-32, вызов gettimeofday предоставляет микросекундную точность.

Аргумент tz в вызове gettimeofday является историческим артефактом.

Системный вызов time возвращает количество секунд, прошедших с начала отсчета времени (то есть точно такое же значение, которое возвращает gettimeofday в поле tv_sec своего аргумента tv).

Функция ctime предоставляет простой метод преобразования значения типа time_t к виду, подходящему для устройств ввода-вывода. Возвращаемая строка будет статически размещенной; последующие вызовы ctime станут ее перезаписывать.

Если нужно работать с возвращенной информацией в ходе нескольких вызовов этих функций, следует сохранять локальные копии (можно использовать реентерабельные функции с суффиксом _r), либо копировать явно.

Функции gmtime и localtime преобразуют значение типа time_t в так называемое broken-down time, разделенное календарное время (или время, разбитое на компоненты). Это время помещается в статически размещаемую структуру, чей адрес возвращается в качестве результата выполнения функции.

Функция mktime преобразует местное время, разбитое на компоненты, в значение типа time_t.

Функция asctime, которой в аргументе timeptr передается указатель на структуру, содержащую раздененное время, возвращает указатель на статически размещенную строку, хранящую время в той же форме, в которой оно возвращается функцией ctime.

Как и в случае применения функции ctime, у нас нет средств для управления форматом строки, создаваемой функцией asctime.

Функция strftime предоставляет нам более тонкую настройку управления при преобразовании разделенного календарного времени в печатный вид.

В отличии от ctime и asctime функция strftime не включает в окончание строки символ новой строки (кроме того, что включается в спецификацию формата, указываемую аргументом format).

Последовательности, начинающиеся с символа процента, являются спецификаторами преобразования.

Функция strptime выполняет преобразование, обратное тому, которое делает функция strftime. Она преобразует строку в виде даты и времени в разделенное календарное время.

Спецификация формата, заданная функцией strptime, похожа на ту, что задается scanf.

Информация о часовом поясе характеризуется, как правило, обширностью и нестабильностью. Поэтому вместо того, чтобы вносить ее в код программ или библиотек напрямую, система хранит эту информацию в файлах в стандартных форматах. Эти файлы находятся в каталоге /usr/share/zoneinfo.

Когда мы указываем программе, какой именно часовой пояс использовать, на самом деле указывается относительное путевое имя для одного из файлов часового пояса в этом каталоге.

Местное время для системы определяется файлом часового пояса /etc/localtime, который часто ссылается на один из файлов в каталоге /usr/share/zoneinfo.

Формат файлов часовых поясов задукоментирован на странице руководства tzfile(5). Файлы часовых поясов создаются с помощью zic, компилятора информации о часовых поясах. С помощью команды zdump можно вывести текущее время для указанных файлов часовых поясов.

Чтобы указать часовой пояс при выполнении программы, переменной среды TZ присваивается значение в виде строки, содержащей символ двоеточия, за которым следует одно из названий часовых поясов, определенное в /usr/share/zoneinfo. Установка часового пояса автоматически влияет на функции ctime, localtime, mktime и strftime. Для получения текущей установки часового пояса в каждой из этх функций применяется функция tzset(3), которая инициализирует три глобальные переменные.

В SUSv3 локаль характерезуется как "подмножество переменных пользовательской среды, которые зависят от языковых и культурных норм".

Так же как информация о часовых поясах, сведения о локали обычно отличаются обширностью и изменчивостью. По этой причине, вместо того чтобы требовать от каждой программы и библиотеки хранения информации о локали, система хранит эти сведения в файлах в стандартных форматах.

Информация о локали содержится в иерархии каталогов, которая находится в каталоге /usr/share/locale (или в каталоге /usr/lib/locale).

Когда в программе указывается, какуб именно локаль использовать, мы, по сути, определяем название одного из подкаталогов, находящихся в каталоге /usr/share/locale.

В каждом подкаталоге локали имеется стандартный набор файлов с указаниями норм, принятых для данной локали.

Команда locale выводит информацию о текущей локали среды (в оболочке).

Для установки и запроса локали программы используется функция setlocale.

Системный вызов settimeofday является обратным функции gettimeofday: он присваивает календарному времени системы значение, соответствующее количеству секунд и микросекунд, заданное в структуре timeval, указатель на которую находится в аргументе tv.

В Linux также предоставляется системный вызов stime, предназначенный для установки системных часов. Разница между предыдущим системным вызовом состоит в том, что последний вызов позволяет установить календарное время с точностью всего лишь в одну секунду. Как и в случае с gettimeofday и time, причина существования stime, так и settimeofday имеет исторические корни.

Резкин изменения системного времени, связанные с вызовами settimeofday, могут плохо влиять на приложения. Поэтому при внесении незначительных изменений в установки времени (неск. секунд) практически всегда предпочтительнее задействовать функцию adjtime, заставляющую системные часы постепенно выйти на требуемое значение.

Точность различных связанных со временем системных вызовов ограничивается разрешением программных системных часов, которые измеряют отрезки времени в единицах, называемых мгновениями. Эта единица измерения используется ядром при выделении процессам времени центрального процессора в соответствии с циклическим алгоритмом его планирования.

Параметр ядра HZ определяет частоту прерываний от таймера. 1000 Гц означает, что прерывания от таймера будут происходить 1000 раз в секунду. Количество прерываний от таймера равно числу мгновений.

Временем процесса называется объем времени центрального процессора, ииспользованный процессом с момента его создания. В целях учета ядро делит время ЦП на следующие два компонента: пользовательское время центрального процессора (выполнение кода в пользовательском режиме) и системное время (выполнение кода в режиме ядра).

При запуске программы из оболочки для получения обоих значений времени процесса, а также реального времени, требуемого для выполнения программы, можно воспользоваться командой time.

Информация о времени процесса может быть извлечена системным вызовом times.

Тип данных clock_t является целочисленным типом, который используется для времени, замеренного в единицах, называемых тиками часов. Чтобы привести его к секундам, надо значение типа clock_t разделить на результат (значение, которое вернула sysconf(_SC_CLK_TCK)).

Простой интерфейс для извлечения времени процесса предоставляется функцией clock. Она возвращает одно значение - замер общего (то есть пользовательского плюс системного) времени центрального процессора, использованного вызывающим процессом.

Каждая реализация UNIX накладывает ограничения (limits) на различные системные характеристики и ресурсы и предоставляемые возможности (options), определенные в различных стандартах (или отказывает в их предоставлении).

Поскольку ограничения и возможночсти системы оказывают влияние на возможности приложения, портируемое приложение нуждается в способах определения значений для ограничений и поддерживаемых возможностей.

Для каждого определяемого ограничения в SUSv3 требуется, чтобы все реализации поддерживали его минимальное значение.

У каждого ограничения есть свое название, которое соответствует показанному выше названию минимального значения, но без префикса _POSIX_.

Указываемые в SUSv3 ограничения разбиты на три категории: значения, не изменяемые динамически, изменяемые значения путевых имен и значения, которые могут увеличиваться динамически.

Не изменяемое динамически значение является ограничением, чье значение, если оно определено в <limits.h>, зафиксировано для реализации. Но значение может быть неопределенным, в силу чего его может не быть в файле <limits.h>. В таком случае (и даже если ограничение задано в файле <limits.h>) приложение для определения значения в ходе своего выполнения может воспользоваться функцией sysconf.

Изменяемые значения путевых имен - это ограничения, относящиеся к путевым именам.

Значения, которое может увеличиваться в ходе выполнения программы, является ограничением, имеющим для конкретной реализации фиксированное минимальное значение. Все системы, в которой запущена данная реализация, будут предоставлять по крайней мере это минимальное значение.

Константы, начинающиеся с _SC_, предназначены для извлечения системных ограничений с помозью sysconf, а константы, начинающиеся с _PC_, предназначены для применения с pathconf и fpathconf.

Для получения ограничений и возможностей конкретной реализации UNIX из оболочки можно использовать команду getconf. Когда ограничение имеет отношение к путевому имени, то в качестве второго аргумента в команде нужно указывать путевое имя.

Функция sysconf позволяет приложению получить значения системных ограничений в ходе выполнения программы.

В SUSv3 требуется, чтобы значение, возвращенное функцией sysconf для конкретного ограничения, было постоянным на всем протяжении жизненного цикла выполнения вызывающего процесса. Например, можно предполагать, что значение, возвращаемое для _SC_PAGESIZE, не будет изменяться, пока продолжается работа процесса.

В ходе своего выполнения приложение может получить значения ограничений, связанных с файлами. Для этого предназначены функции pathconf и fpathconf.

Аргумент name является одной из констант вида _PC_*, определенный в <unistd.h>.

Наряду с указанием ограничений для различных системных ресурсов в SUSv3 указываются различные возможности, которые могут поддерживаться реализацией UNIX.

До появления виртуальной файловой системы /proc в старых системах UNIX ответы на вопросы "Сколько процессов запущено в системе?","Какие файлы открыты процессом?" и т.д эта проблема решалась тем, что привилегированным программам разрешалось анализировать структуры данных в ядре. Но такой подход имел несколько недостатков. В частности, он требовал специализированных знаний о структуре данных ядра, а эти структуры могли претерпевать изменения из за чего программы нередко нужно было переделывать.

Файловая система /proc называется виртуальной потому, что содержищиеся в ней файлы и подкаталоги не находятся на диске. Вместо этого ядро создает их на лету по мере обращения к ним процессов.

Для каждого процесса в системе ядро предоставляет соответствующий каталог по имени /proc/PID, где PID является идентификатором процесса. Внутри этого каталога находятся различные файлы и подкаталоги, содержащие информацию о процессе.

Среди файлов в каждом каталоге /proc/PID есть файл status, который дает множество данных о процессе.

Для удобства, любой процесс может обратиться к своему собственному каталогу /proc/PID с помощью символьной ссылки /proc/self.

Доступ к информации, распространяющейся на всю систему, предоставляется в различных файлах и подкаталогах, находящихся в /proc.

Некоторые /proc файлы могут быть прочитаны только их владельцем (или рутом). Например, все файлы, находящиеся в каталоге /proc/PID, яляются собственностью пользователя, владеющего этим процессом и в отношении некоторых из них прва на чтение даются только владельцу файла.

Кроме файлов в подкаталогах /proc/PID, большинство файлов в каталоге /proc являются собственностью суп польз, и те файлы, в которые разрешено вносить изменения, могут быть изменены только этим пользователем.

Каталоги /proc/PID не существуют постоянно. Каждый из них появляется с созданием процесса с соответствующим идентификатором и исчезает, как только процесс завершится.

Системный вызов uname возвращает идентифицирующую информацию о базовой системе.

Для достижения высокой скорости и эффективности работы систем вызовы ввода-вывода (то есть ядро) и функции ввода вывода ст библ языка С (то есть функции stdio) при работе с дисковыми файлами осуществляют буферизацию данных.

При работе с файлами на диске сис выз read и write не инициируют непосредственный доступ к диску. Вместо этого они просто копируют данные между буфером в пространстве памяти пользователя и буфером в буферном кэше ядра.

Несколько позже ядро записывает (сбрасывает) свой буфер на диск. (В связи с этим говорится, что сист выз не сихронизирован с дисковой операцией.)

Независимо от того, выполняется 1000 записей одного байта или единая запись 1000 байт, ядро осуществляет одинаковое количество обращений к диску. Но последний вариант более предпочтителен, поскольку требует одного сис выз, тогда как для первого их требуется аж тыща.

Если переноситься большой объем данных в файл или из файла, то буферизаци данных в больших блоках и, в силу этого, выполнения меньшего количества системных вызовов (косвенно, уменьшается именно количество обращений к диску) позволяют нам существенно повысить производительность ввода-вывода.

Основная часть времени в строках, соответствующих большим размерам буфера затрачивается на считывание данных с диска. В последнем случае, оказывается! дисковый ввод вывод фактически не выполняется (кроме первой загрузки файла в буфер).

Для того чтобы сократить количество системных вызовов, при работе с файлами на диске буферазация данных в большие блоки осуществляется внутри функций ввода-вывода библиотеки языка С. Таким образом, библиотека stdio берет на себя работу по буферизации данных для их вывода с помощью write и read.

Функция setvbuf позволяет выбрать способ буферизации, которую будет применять библиотека stdio.

Функция setbuf является надстройкой над setvbuf и выполняет точно такую же задачу.

Функция setbuffer аналогична setbuf, но позволяет вызывающему коду указать размер буфера buf.

Независимо от текущего режима буферизации, в любое время можно принудительно записать данные, в любое время можно принудительно записать данные, находящиеся в выходном потоке stdio (то есть сбросить буфер ядра на диск посредством write)), воспользовавшись библиотечной функцией fflush.

Когда соответствующий поток закрывается, буфер stdio автоматически сбрасывается.

Сброс буферное памяти ядра для файлов вывода можно сделать принудительным. 

В SUSv3 понятие синхронизированного завершения ввода вывода означает "операцию ввода-вывода, которая либо привела к успешному переносу данных [на диск], либо была диагностирована как неудачная".

Системный вызов fsync приводит к сбросу всех буферизованных данных и всех метаданных, которые связаны с открытым файлом, имеющим дескриптор fd. Вызов fsync приводит файл в состояние целостности (файла) после завершения синхронного ввода вывода.

Системный вызов fdatasync работает точно также, как и fsync, но приводит файл в состояние целостности (данных) после завершения синхронного (синхронизированного) ввода-вывода. Этот сис вызов потенциально сокращает количество дисковых операций, необходимых системному вызову fsync, до одного.

Системный вызов sync приводит к тому, что все буферы ядра, содержащие обновленную файловую информацию (то есть блоки данных, блоки указателей, метаданные и т.д), сбрасываются на диск.

Указание флага O_SYNC при вызове open приводит к тому, что все последующие операции вывода выполняются в синхронном режиме.

Современные дисковые накопители обладают внутренней кеш-память большого объема, и по умолчанию установка флага O_SYNC просто приводит к переносу данных в эту кеш-память. Если отключить кеширование на диске, влияние O_SYNC на производительность станет еще более существенным. При размере буфера 1 байт затраченное время возрастет с 1030 секунд до приблизительно 16000 секунд.

Системный вызов posix_fadvise позволяет процессу информировать ядро о предпочитаемой им схеме обращения к данным файла.

Начиная с версии ядра 2.4 Linux позволяет приложению обходить буферную кеш память при выполнеии дискового ввода-вывода, перемещая данные непосредственно из пользовательского пространства памяти в файл или на дисковое устройство. Иногда этот режим называют непосредственным или необрабатываемым вводом-выводом.

Для выполнения io для одного и того же файла можно совмещать использование системных вызовов и стандартных функций библиотеки языка С. Помочь в этом могут функции fileno и fdopen.

Для данного потока функция fileno возвращает соответствующий файловый дескриптор (то есть тот самый, который библиотека stdio открыла для этого потока).Функция fdopen является обратной функции fileno.

При задействовании функций библиотеки stdio в сочетании с системными вызовами ввода вывода для выполнения этих операций в отношении дисковых файлов нужно учитывать вопросы буферизации.

Чтобы избежать проблемы, возникающей при смешивании системных вызовов и функий stdio для ввода вывода, может потребоваться грамотное использ функц fflush.

Специальный файл устройства соответствует какому либо устройству в системе. Внутри ядра каждому типу устройства соответствует драйвер устройства, который обрабатывает для него все запросы на ввод-вывод. Драйвер устройства - это модуль программного кода ядра, реализующий набор операций, которые (как правило) соответствуют операциям ввода-вывода на связанном аппаратном средстве. Тот факт, что каждый драйвер устройства обеспечивает единый интерфейс, скрывающий различия в работе отдельных устройств, позволяет добиться универсальности ввода-вывода.

Некоторые устройства являются реальными, например мыши, диски, другие - виртуальными (им не соответствует никакое аппаратное средство, а вместо него ядро предоставляет (с помощью драйвера устройства) абстрактное устройство с API таким же, как у реального устройства).

Файлы устройств располагаются внутри файловой системы, подобно другим файлам, обычно в каталоге /dev. Суперпользователь может создать файл устройства с помощью команды mknod.

Каждый файл устройства имеет старший идентификационный номер и младший идентификационный номер. Старший номер идентифицирует общий класс устройства и используется ядром для поиска драйвера, который подходит для данного типа устройства. Младший номер уникальным номером идентифицирует устройство внутри общего класса (их можно вывести с помощью ls -l). Они оба записаны в индексном дескрипторе для данного файла устройства.

Каждый драйвер устройства регистрирует свою привязку к определенному старшему идентиф номеру, и она обеспечивает соединение между специальным файлом устройства и его драйвером. Когда ядро отыскивает драйвер устройства, имя файла устройства не имеет значения.

Каждый диск имеет один или несколько (неперекрывающихся) разделов. Каждый раздел воспринимается ядром как отдельное устройство, расположенное в каталоге /dev.

Дисковый раздел может содержать информацию любого типа, но обычно содержит что либо из перечисленного ниже:
1) файловую систему
2) область данных, которая доступна в качестве устройства с прямой пересылкой данных
3) область подкачки, которая применяется ядром для управления памятью

Область подкачки создается с помошью команды mkswap.

Особый файл Linux /proc/swaps можно применять для отображения информации об областях подкачки, задействованных в данный момент в системе.

Файловая система - это упорядоченный набор обычных файлов и каталогов. Она создается с помощью команды mkfs.

Одной из сильных сторон Linux является возможность поддержки самых разных файловых систем.

Типы файловых систем, которые в данный момент распознаны ядром, можно просмотреть о особом файле Linux /proc/filesystems.

Таблица индексных дескрипторов файловой системы содержит по одному индексному дескриптору на каждый файл, расположенный в данной файловой системе. Они идентифицируются с помощью номеров в порядке их следования в таблице индексных дескрипторов (ls -li).

Подобно большинству файловых систем UNIX, файловая система ext2 не хранит блоки данных какого-либо файла рядом друг с другом или в порядке их следования (но все же пытается размещать их близко друг к другу). Для локализации блоков данных файла ядро хранит набор указателей в индексном дескрипторе.

Если бы каждой программе, которая работает с файлами, потребовалось вникать в особенности каждой файловой системы, то тогда задача по написаню программ, работающих во всех файловых системах, стала бы практически неосуществимой. Виртуальная файловая система - это функция ядра, которая решает названную проблему, создавая уровень абстракции для операций файловой системы (т.е это уровень абстракции поверх конкретной реализации файловой системы).

Принципы виртуальной файловой системы просты:

Она определяет обобщенный интерфейс для операций файловой системы. Все программы, которые работают с файлами, выражают свои операции в терминах данного обобщенного интерфейса.

Каждая файловая система обеспечивает реализацию интерфейса виртуальной файловой системы.

Согласно этой схеме программам необходимо понимать только VFS-интерфейс.

В Linux, как и в других UNIX системах, все файлы из всех файловых систем располагаются в одном дереве каталогов. В основании этого дерева находится корневой каталог (/). Другие файловые системы монтируются в корневом каталоге и возникают как поддеревья в общей иерархии.

Монтирование файловой системы - системный процесс, подготавливающий раздел диска к использованию операционной системой.

Файловая система устанавливает, где и как будет записан файл на физическом носителе.

mount device dir - эта команда "прикрепляет" файловую систему к устройству device в указанном каталоге directory в иерарархии каталогов - в точке монтирования данной файловой системы.

Чтобы вывести список смонтированнах в данный момент ФС, можно использовать команду mount без аргументов.

Список смонтированный в данный момент файловых систем можно считать из характерного для линукс виртуального файла /proc/mounts.

Все файловые системы, расмотренные ранее в этой главе, размещаются на дисках. Однако в линукс поддерживаются также виртуальные файловые системы, которые располагаются в памяти. Для приложения они выглядят подобно любой другой файловой системе: к файлам и каталогам можно применять все те же операции. Но есть одно важное отличие: файловые операции осуществляются намного быстрее, посколько не задействован доступ к диску.

Системные вызовы stat, lstat, fstat извлекают информацию о файле, в основном из индексного дескриптора файла.

Поле st_mode является битовой маской, которая служит двум целям: идентификации типа файла и указанием прав доступа к нему.

В Linux для обозначения типа файла использованы четыре бита поля st_mode. Но, поскольку в SUSv3 не оговорено, каким образом представлять тип файла, детали могут быть различными в разных реализациях.

512 байт - это наименьший размер логического блока для любой из файловых сисстем, которые были реализованы в UNIX.

Поля time_t - стандартный для UNIX формат времени в секундах, прошедших с начала "эры UNIX" - 1 января 1970 года.

Поля st_atime, st_mtime, st_ctime структуры stat содержат файловые метки времени. В эти поля записываются соответственно время последнего доступа к файлу, время последнего изменения файла и время последнего изменения статуса файла (то есть последнего изменения информации в файловом дескрипторе).

Начиная с версии 2.6, Линукс поддерживает наносекундную точность для трех полей с метками времени в структуре stat.

В API glibc (с версии 2.3) каждое поле меток времени определяется как структура timespec (было time_t), которая представляет время в виде секундного и наносекундного компонентов.

Метки времени последнего доступа к файлу или его изменения, хранящиеся в индексном дескрипторе файла, можно явным образом изменить с помощью системного вызова utime или другого из связ набора сис вызовов.

В Линукс есть также заимствованный из системы BSD системный вызов utimes, выполняющий задачу, сходную с задачей utime. Самым заметным отличием между ними является то, что второй позволяет указывать значения времени с микросекундной точностью.

Библиотечные функции futimes и lutimes работают подобно системному вызову utimes. Они отличаются от него аргументом, служащим для указания файла, метки времени которого следует изменить.

Системный вызов utimensat и библиотечная функция futimensat позволяют в расширенном диапазоне задавать метки времени последнего доступа к файлу или времени его последнего изменения. Основное преимущество: возможно задавать метки времени с наносекундной точностью.

С каждым файлом связаны идентификатор пользователя (UID) и идентификатор группы (GID). Эти идентификаторы определяют, какому пользователю и какой группе принадлежит файл.

При создании нового файла его идентификатор пользователя заимствуется от действующего ID пользователя для процесса. Идентификатор группы для нового файла может быть взят либо от действующего идентификатора группы для процесса, либо от идентификатора группы для родительского каталога.

Это значение зависит от различных факторов. В их число входит тип файловой системы, в которой создается новый файл.

Системные вызовы chown, lchown, fchown изменяют владельца (идентификатор пользователя) и группу (идентификатор группы) файла.

Передав в качестве аргумента значение -1 можно оставить соответствующий идентификатор без изменений.

Только привилегированный процесс может использовать сис выз chown для изменения идент пользователя файла. Непривилегированный процесс может задействовать его для изменения GID для файла, которым он обладает (то есть eUID для процесса совпадает с UID этого файла) для любой из групп, членом которой он является. Привил процесс может изменить идент группы файла на любое значение.

Первые 3 из 12 битов маски прав доступа являются специальными и называются set-user-ID, set-group-ID и бит закрепления (U, G, T).

Бит выполнения: данный файл можно выполнить (то есть это программа или сценарий). Для запуска файла сценарий (например, bash) необходимо наличие прав на чтение и выполнение.

Для каталогов применяется та же схема прав доступа, что и для файлов. Однако три варианта прав доступа интерпретируются иначе.
Чтение. Содержимое (то есть список имен файлов) каталога можно вывести.
Запись. В данном каталоге можно создавать файлы или удалять из него. Обратите внимание: в этом случае не обязательно иметь какие либо права доступа к файлу, чтобы удалить его. То есть чтобы удалить файл из каталога, мне нужно иметь право на запись в этот каталог, а права файла здесь не причем.
Выполнение. К файлам в каталоге разрешен доступ. Разрешение на выполнение применительно к каталогу иногда называют разрешение на поиск.

При доступе к файлу разрешение на выполнение необходимо для всех каталогов, которые содержатся в имени пути. С относительными путями ситуация другая. Если текущим рабочим каталогом является /home/mtk/sub1 а мы осуществляет доступ по относительному имени пути ../sub2/x, то в этом случае необходимо иметь разрешение на выполнение для каталогов /home/mtk и /home/mtk/sub2, но не для каталога / или /home).

Следует иметь разрешение на выполнение для каталога, чтобы получить доступ к его содержимому или к информации индексных дескрипоров файлов в данном каталоге.

Ядро проверяет права доступа к файлу всякий раз при указании имени пути в системном вызове, который осуществляет доступ к файлу или к каталогу. Если имя пути, переданного системному вызову, содержит префикс каталога, то, помимо необходимых прав доступа к самому файлу, ядро проверяет также разрешение на выполнение для каждого каталога в таком префиксе.

Как только файл открывается с помощью сис выз open, последующие системные вызовы, которые работают с возвращенным дескриптором, не выполняют проверку прав доступа.

Поскольку информация о правах доступа к файлу и о его принадлежности содержится в индексном дескрипторе файла, все имена файлов (ссылки), которые указывают на один и тот же индексный дескриптор, будут совместно использовать эту информацию.

Действующие идентификаторы пользователя и группы, а также добавочной группы используются для определения прав доступа, которыми обладает процесс при доступе к файлу (идентификатор пользователя\группы файловой системы в Linux).

У программы (работающей, например, с полномочиями setuid и setgid) есть возможность проверить доступность файла на основе реальный идентификаторов пользователя и группы для процесса.

Сис выз access проверять доступность файла на основе реальных идентификаторов пользователя и группы (а также идентификаторов добавочных групп) для процесса.

Наличие временного интервала между системным вызовом access и последующей операцией с файлом означает следующее: нет никакой гарантии того, что информация, возвращенная этим сис вызовом, останется истинной к моменту выполнения операции (вне зависимости от того, насколько краток этот интервал).

В ранних реализациях UNIX закрепляющий бит служил как средство более быстрого выполнения часто применяемых программ. Если он был установлен, то при первом запуске копия текста программы сохранялась в область подкачки - закреплялась в ней и загружалась быстрее при последующих выполнениях. В современных реализациях UNIX системы управления памятью более сложные, и поэтому приведенный вариант использования закрепляющего бита устарел. В современных реализациях UNIX (включая Linux) бит закрепления служит совершенно другой цели. Для каталогов он действует как флаг запрещения удаления.

Если бит установлен для каталога, то непривилегированный процесс может расцеплять и переименовывать файлы в данном каталоге, только если у него есть право записи для каталога и он является владельцем либо файла, либо каталога. (Он установлен для каталога /tmp).

Указанные права при создании файла или каталога изменяются с помощью маски режима создания файла, которая известна как umask. Этот параметр - атрибут процесса, указывающего, какой из битов прав доступа следует всегда отключать при создании данным процессом новых файлов или каталогов. Зачастую процесс задействует атрибут umask, который он наследует от своей родительской оболочки.

Системный вызов umask изменяет атрибут umask для процесса на значение, указанное в аргументе mask.

Файлы инициализации в большинстве оболочек по умолчанию устанавливают для атрибута umask восьмеричное значение 022 (----w--w-).

Системные вызовы chmod и fchmod изменяют права доступа к файлу.

Для изменения прав доступа к файлу необходимо, чтобы процесс был привилегированным либо чтобы его действующий (файловой системы для Linux) UID совпадал с владельцем (UID) для файла.

Ряд файловых систем Linux допускают устанавливать для файлов и каталогов различные флаги индексного дескриптора. Эта функция является нестандартным расширением Linux.

Первой файловой системой Linux, которая стала поддерживать флаги индексного дескриптора, оказалась ext2, и поэтому такие флаги иногда называют расширенными атрибутами файла в файловой системе ext2.

Количество флагов индексного дескриптора немного различается для разных файловых систем.

Напрямую из оболочки флаги индексного дескриптора можно установить и просмотреть с помощью команд chattr и lsattr.

Внутри какой либо программы флаги индексного дескриптора (как их еще называеют - расширенные атрибуты файла в файловой системе ext2) можно извлечь и изменить с помощью системного вызова ioctl.

Внутри программы флаги индексного дескриптора можно извлечь и изменить с помощью операций ioctl FS_IOC_GETFLAGS и FS_IOC_SETFLAGS.

Для изменения флагов индексного дескриптора файла, необходимо, чтобы EUID для процесса соответствовал идентификатору пользователя (владельца) файла, либо чтобы процесс был привилегированным. (Если говорить абсолютно точно, .... идентификатор пользователя в файловой системе процесса .... 9.5 ....).

Флаги индексного дескриптора управляют различными вариантами поведения файлов и каталогов. Несмотря на то что они изначально были определены для файловой системы ext2, теперь эти флаги поддерживаются и в некоторых других системах.

В данной главе описаны расширенные атрибуты (extended attributes, EA), допускающие использование произвольных метаданных в виде пар "имя-значение", привязанных к индексным дескрипторам. Они появились в версии Linux 2.6.

Расширенные атрибуты служат для реализации списка контроля доступа и возможностями файла.

Расширенным атрибутам требуется поддержка со стороны основной файловой системы.

Имена расширенных атрибутов представлены в виде пары namespace.name. Левый компонент предназначен для разграничения атрибутов по функционально различным классам. Правый уникальным образом идентифицирует расширенный атрибут внутри данного пространства namespace.

Индексный дескриптор может обладать несколькими связанными с ним расширенными атрибутами, из одного пространства имен или из разных.

Для установки и просмотра расширенных атрибутов файла можно использовать команды оболочки setfattr и getfattr.

Значение расширенного атрибута может быть пустой строкой, и это не то же самое, что неопределенный расширенный атрибут.

С помощью системных вызовов setxattr, lsetxattr fsetxattr.

С помощью системных вызово getxattr, lgetxattr, fgetxattr можно извлечь значение EA.

Системные вызовы removexattr, lremovexattr, fremovexattr удаляет расширенный атрибут файла.

Системные вызовы listxattr, llistxattr, flishxattr возвращают список, содержащий имена всех расширенных атрибутов, связанных с файлом.

Каждый процесс имеет два атрибута, относящихся к каталогу: корневой каталог, задающий точку, относительно которой интерпретируются абсолютные имена путей, и рабочий каталог, задающий точку, относительно которой интерпретируются относительные имена путей.

Каталог хранится в системе, подобно обычному файлу. Две особенности отличают каталог от обычного файла:
1) для каталога указывается другой тип файл в записи индексного дескриптора.2) каталог является файлом с особым упорядочением. По сути, это таблица, состоящая из имен файлов и номеров индексных дескрипторов.

Несмотря на то что процесс может открыть каталог, о не может применять сис вызов read для чтения его содержимого. Не может процесс и изменить содержимое каталога с помощью системного вызова write; он может лишь косвенно (то есть через запрос к ядру) менять содержимое благодаря таким системным вызовам, как open, link, mkdir, symlink, unlink, rmdir.

Нумерация в табл инд дескрипторов начинается с 1, а не с 0, поскольку значение 0 в поле индексного дескриптора для каталога говорит о том, что данная запись не используется. Индексный дескриптор 1 применяется для маркировки неисправных блоков в ФС. Корневой каталог системы / всегда хранится в записи индексного дескриптора 2, чтобы ядро знало, откуда начинать анализ имени пути.

Если обратиться к списку информации, хранимой в индексном дескрипторе файла, можно увидеть, что индексный дескриптор не содержит имени файла; оно определяется только путем сопоставления внутри списка каталога. Это приводит к удобному следствию: можно создавать несколько имен - в том же каталоге или в каком то другом, - соотносящихся с одним и тем же индексным дескриптором. Такие имена называются ссылками, или жесткими ссылками.

Работая в оболочке, можно создать новые жесткие ссылки на существующий файл с помощью команды ln. (тогда имена будут соотносится с одной и той же записью индексного дескриптора и, следовательно, с одним и тем же файлом).

Запись индексного дескриптора и блоки данных удаляются (освобождаются), только когда счетчик ссылок становиться нулевым - то есть после удаления влех имен данного файла.

Все имена (ссылки) для какого либо файла являются эквивалентными.

У жестких ссылок есть два ограничения, которые можно обойти за счет использования символических ссылок:
1) поскольку запись каталога (жесткие ссылки) соотносятся с файлами только с помощью номера индексного дескриптора, а такие номера являются уникальными лишь в пределах одной файловой системы, жесткая ссылка должна находиться в той же файловой системе, что и файл, на который она указывает.
2) невозможно создать жесткую ссылку на каталог. Это предотвращает создание циклических ссылок, которые создавали бы помехи в работе многих системных программ.

Символическая ссылка, иногда называемая мягкой ссылкой, является специальным типом файла, данные которого - это имя другого файла.

В сеансе оболочки символические ссылки создаются с помощью команды ln -s.

Имя пути, с которым соотносится символическая ссылка, может быть либо абсолютным, либо относительным. Относительная символическая ссылка интерпретируется по отношению к местоположению самой ссылки.

Символические ссылки не учитываются в счетчике ссылок (жестких) для файла, на который указывает. Следовательно, если удалить имя файла, с которым соотносится симв ссылка, то сама она останется, несмотря на то, что ее нельзя будет разыменовать (проследовать по ней). О такой ссылке говорят, что она стала зависшей. Можно даже создать символическую ссылку на имя файла, который не существует на момент ее создания :-).

Поскольку симв ссылка соотносится с именем файла, а не с номером индесксного дескриптора, ее можно использовать для указания на файл в иной файловой системе. Симв ссылки избавлены также от друг огр, характ для жестких: можно создавать символические ссылки на каталоги.

Многие (но не все) системные вызовы разыменовывают символические ссылки (следуют по ним) и таким образом работают с файлом, на который указывает ссылка.

В ряде случаев, когда необходимо обеспечить одинаковое функционирование как для файла, с которым соотносится символическая ссылка, так и для нее самой, применяют взаимоисключающие системн вызовы: один из них разымен ссылку, а второй - нет, причем этот вызов снабжен префиксом в виде буквы l.

Символические ссылки всегда создаются с предоставлением всех прав доступа.

Вместо них при определении того, допустима ли какая-либо операция, используются принадлежность и права доступа к файлу, на который указывает ссылка. Принадлежность симв ссылки имеет значение, только когда сама ссылка удаляется или переименовывается в каталоге, для которого установлен закрепляющий бит прв доступа.

Системные вызовы link и unlink создают и удаляют жесткие ссылки.

Нельзя использовать системный вызов unlink для удаления каталога; для этой задачи нужны системные вызовы rmdir или remove.

Помимо отслеживания счетчика ссылок для каждого индексного дескриптора ядро считает также открытые файловые дескрипторы данного файла. Если удалена последняя ссылка на файл, но какие либо процессы удерживают открытыми дескрипторы, относящиеся к этому файлу, то он не будет фактически удален до тех пор, пока не будут закрыты все дескрипторы.

Даже когда удалена последняя ссылка на файл, сам он удаляется только после закрытия всех файловых дескрипторов, соотнесеных с ним.

Системный вызов rename можно использовать как для переименования файла, так и для его перемещения в другой каталог той же файловой системы.

Системный вызов rename оперирует записями каталога; он не перемещает данные файла. Переименование не отражается на других жестких ссылках, связанных с этим файлом, оно не влияет так же ни на какие процессы, удерживающие открытыми дескрипторы данного файла, поскольку такие дескрипторы соотносятся с открытыми файловыми дескрипторами которые (после вызова open()) не связаны с именами файлов.

Файлы, с которыми соотносятся аргументы oldpath и newpath, должны располагаться в одной файловой системе. Это необходимо, поскольку каталог является списком жестких ссылок, указывающих на индексные дескрипторы в той же файловой системе, где расположен данный каталог.

Системный вызов symlink создает новую символическую ссылку linkpath для имени пути, указанного в аргументе filepath. (Чтобы удалить ее, используется системный вызов unlink.)

Символическая ссылка, ссылающаяся на несуществующий файл\каталог называется зависшей.

Системный вызов readlink помещает копию строки символической ссылки в символьный массив, на который указывает аргумент buffer.

Cистемный вызов mkdir создает новый каталог.

umask - маска процесса.

Только что созданный каталог содержит две записи: ., которая является ссылкой на сам каталог, и .. - это ссылка на родительский каталог. Стандарт SUSv3 не требует наличия этих записей. Он требует лишь того, чтобы в реализации системы корректно интерпретировались эти точки, когда они появляются в именах путей. Портируемое приложение не должно полагаться на существование таких записей в каталоге.

Системный вызов rmdir удаляет каталог, указанный в имени пути pathname, который может быть абсолютным или относительным (для успешного завершения каталог должен быть пустым).

Библиотечная функция remove удаляет файл или пустой каталог. Эта функция была введена в стандартную библиотеку С, которая реализована как в системах UNIX, так и в других. В большинстве систем, отличных от UNIX, не поддерживаются жесткие ссылки, и поэтому удаление файлов с помощью функции unlink не имело бы смысла.

Библиотечные функции для чтения каталогов основаны на системном вызове getdents (не явл частью стандарта SUSv3), однако обеспечивают интерфейс, более удобный в использовании. В Линукс есть также системный вызов readdir(2) (в отличие от библ функции readdir, описанной здесь), который выполняет ту же задачу, что и getdents, но является устаревшим).

Структура DIR представляет собой так называемый поток каталога.

После получения результата функции opendir поток каталога размещается в первой записи списка каталога.

Функция readdir считывает последовательные записи из потока каталога.

Дальнейшую информацию о файле, на который указывает аргумент d_name, можно получить благодаря системному вызову stat для имени пути, составленному с помощью аргумента dirpath, указанного для функции opendir, сцепленного (с помощью слеша) со значением, возвращаемым в поле d_name.

Имена файлов, возвращаемые readdir, располагаются не в порядке сортировки, а в порядке появления в каталоге.

При достижении конца каталога или при ошибке функция readdir возвращает NULL.

Функция rewinddir перемещает поток каталога обратно к началу, чтобы следующий вызов функции readdir начинал работу с первого файла в данном каталоге.

Функция closedir закрывает открытый поток каталога, на который указывает аргумент dirp, высвобождая ресурсы, использованные этим каталогом.

telldir и seekdir, которые также определены в стандарте SUSv3, разрешают произвольный доступ внутри потока каталога.

Поток каталога обладает связанным с ним файловым дескриптором. Функция dirfd возвращает дескриптор, относящийся к потоку каталога, на который указывает аргумент dirp.

Функция opendir автоматически устанавливает флаг close-on-exec (FD_CLOEXEC) для файлового дескриптора, связанного с потоком каталога.

Функция readdir_r является вариантом функции readdir. Ключевым семантическим различие между этим функциями является то, что первая допускает многократое ввод, а вторая - нет.

Функция nftw позволяет программе рекурсивно перемещаться по всему поддереву каталога, выполняя некую операцию для каждого файла в этом поддереве. По умолчанию она выполняет несортированный обход указанного дерева в прямом порядке, обрабатывая каждый каталог, прежде чем перейти к обработке файлов и подкаталогов внутри данного каталога.

Текущий рабочий каталог процесса задает исходную точку для анализа относительных имен путей, на которые ссылается процесс. Новый процесс наследует свой текущий рабочий каталог от родительского процесса.

Процесс может извлечь имя своего текущего рабочего каталога с помощью функции getcwd.

Системный вызов chdir меняет рабочий каталог вызывающего процесса на относительное или абсолютное имя пути, переданное в аргументе pathname.

Системный вызов fchdir выполяет то же, что и вызов chdir, только каталог указывается с помощью файлового дескриптора, полученного ранее при открытии каталога, задействуя системный вызов open.

Начиная с версии ядра 2.6.16 Linux предлагает ряд новых системных вызовов, выполняющие задачи, сходные с задачами традиционных вызовов, но обеспечивающие дополнительную функциональность, которая может быть удобна в отдельных приложениях.

Каждый процесс обладает корневым каталогом - он представляет собой точку отсчета, от которой интерпретируются абсолютные имена путей (то есть начинающиеся с символа /). Новый процесс наследует корневой каталог своего родителя. По умолчанию данным каталогом является реальный корневой каталог файловой системы. Изменить корневой каталог процесса можно с помощью системного вызова chroot.

Корневой каталог любого процесса можно найти, прочитав (readlink) содержимое характерной для Linux символической ссылки /proc/PID/root.

Корневой каталог является собственным родителем; то есть путь /.. - ссылка на /).

Библиотечная функция realpath разыменовывает все символические ссылки в аргументе pathname и выполняет анализ всех ссылок на /. и /.., чтобы выдать строку с завершающим нулем, содержащую соответствующее абсолютное имя пути.

Функции dirname и basename разбивают строку с именем пути на имя каталога и файловые имена частей.

Имена назначаются файлам путем записей в каталогах, которые являются таблицами, перечисляющими имена файлов с соответствующими номерами индексных дескрипторов. Такие записи называют (жесткими) ссылками.

Начиная с версии ядра 2.6.13 Linux предоставляет механизм inotify, позволяющий приложениям осуществлять мониторинг событий файлов. Он призван заменть устаревший механизм dnotify, предоставляющий лишь часть возможностей dnotify. 

Оба этих механизма специфичные для Linux.

Вызов inotify_init создает объект inotify внутри памяти ядра.

Приложение информирует ядро о том, какие файлы ему необходимы, с помощью функции inotify_and_watch для добавления элементов в список наблюдения объекта inotify, созданного в предыдущем шаге.

Системный вызов inotify_rm_watch выполняет обратную операцию - удаляет объект наблюдения, ранее уже добавленный в список.

Чтобы получить оповещения о событиях, приложение выполняет для дескриптора файла inotify операции чтения read.

По завершении мониторинга приложение закрывает дескриптор файла inotify. Это позволяет уалить все элементы списка наблюдения, связанные с объектом inotify.

Если к данному моменту никаких событий не случилось, то функция read блокируется до свершения какого-либо события (если для файлового описателя не был устанновлен флаг O_NONBLOCK, в случае чего функция read завершается с ошибкой EAGAIN при отсутствии доступных событий).

Мы не может использоваться inotify для достоверного определения того, сколько раз или как часто происходило повторяющееся событие.

Файлы конфигурации: /proc/sys/fs/inotify/{max_queued_events,max_user_instances,max_user_watches}.

Механизм inotify не использует файловые дескрипторы.

Сигнал - это оповещение процесса о том, что произошло некое событие. Иногда сигналы описываются как программные прерывания. Они аналогичны аппаратным прерываниям в том смысле, что они останавливают нормальное выполнение программы.

Один процесс может (при наличии необх разрешений) отправить сигнал другому процессу. При таком использовании сигналы могут рассм как технология синхронизации либо даже как примитивная форма межпроцессного взаимодействия (IPC).

Обычно источником большинства сигналов, отправляемых в процесс, является ядро.

Сигналы можно разделить на две большие категории. Первый набор сигналов состоит из традиционных, или стандартных сигналов, которые используются ядром для оповещения процессов о свершении событий (1-31). Второй набор состоит из сигналов реального времени.

Говорят, что сигнал генерируется каким либо событием. После генерации происходит доставка в процесс, который затем выполняет определенные действия для ответа на полученный сигнал.

После того, как сигнал был сгенерирован, и до его доставки, говорят, что сигнал находится в состоянии ожидания.

Сигнальная маска процесса позволяет временно заблокировать доставку сигнала до тех пор, пока не будет разблокирован (удален из сигнальной маски).

Для каждого конкретного сигнала программа может изменить действие, выполняемое при его получении. Это называется установкой диспозиции сигнала.

Обработчик сигнала - функция, написанная программистом и выполняющая нужные действия при получении сигнала.

Когда в ответ на получение сигнала программа активирует соотв обработчик, мы говорим, что сигнал был обработан или, что синонимично, перехвачен.

SIGTERM - стандартный сигнал, который применяется для завершения процесса и по умолчанию посылается командами kill, killall. У хорошо спроектированного приложения будет обработчик для SIGTERM, который вызывает корректное завершение приложения, позволяя ему стереть временные файлы и заблаговременно высвободить другие ресурсы. Завершение процесса с помозью SIGKILL обходит обработчик SIGTERM. Следовательно, мы всегда должны сначала попытаться завершить процесс, используя SIGTERM, и принебречь SIGKILL в качестве последнего средства для завершения вышедших из под контроля процессов, не отвечающих SIGTERM.

В системах UNIX предоставляется два способа изменения диспозиции сигнала: signal, sigaction.

Несмотря на то что функция signal задокументирована во втором разделе справочных страниц Linux, на самом деле эта функция реализована в glibc как библиотечная, реализованная поверх системного вызова sigaction.

Обработчик сигнала (также называемый перехватчиком сигнала) - это функция, вызываемая при получении указанного сигнала процессом.

Драйвер терминала генерирует сигнал SIGINT при вводе с клавиатуры символа прерывания, обычно это сочетание клавиш Ctrl+C).

Оповещение ядра о необходимости активации функции обработчика сигнала называтся установкой или настройкой обработчика сигнала.

После активации ядром обработчика сигнала, номер сигнала, ставшего причиной активации, передается в обработчик в виде целочисленного аргумента.

Один процесс может отправить сигнал другому процессу с помощью системного вызова kill.

Процессу для отправки сигнала другому процессу требуются соответствующие разрешения.

Непривилегированный процесс может отправлять сигнал другому процессу, если реальный или эффективный ID пользователя процесса, отправляющего сигнал, совпадает с реальным или сохраненным установленным ID пользователя процесса, получающего сигнал.

Системный вызов kill может также служить другой цели. Если параметр sig указан как 0 (так называемый нулевой сигнал), то никакой сигнал не отправляется. Вместо этого функция kill лишь выполняет проверку ошибок, удостоверяясь в том, есть ли возможность отправки сигнала в процесс. То есть мы можем использовать нулевой сигнал для тестирования наличия процесса с указанным идентфикатором.

Для проверки того, запущен ли тот или иной процесс, могут применятся другие методы:
1) системные вызовы wait
2) семафоры и исключающие файловые блокировки
3) каналы ipc, такие как простые поименованные каналы и каналы FIFO.
4) интерфейс /proc/PID

Иногда полезной практикой является отправка процессом сигнала самому себе. Эту задачу выполняет функция raise (С89).

Стандарты языка С не затрагивают детали реализации ОС, такие как идентификаторы процессов.

Когда процесс посылает сигнал самому себе с помощью функции raise, сигнал доставляется моментально (иными словами, перед тем, как функция raise вернет управление в вызвавший ее код). Т.е после отправки сигнала, он будет сначала обратан и только поток, ход выполнения программы продолжится после точки вызова raise.

Функция killpg посылает сигналы всем процессам в группе.

Для каждого сигнала существует выводимое на печать описание. Все описания храняться в массиве sys_siglist. Но вместо использования массива sys_siglist напрямую предпочтительнее вызывать функцию strsignal.

Кроме проверки соблюдения границ, у функции strsignal есть дополнительное преимузество над непосредственным применением массива sys_siglist. Оно состоит в том, что функция strsignal чувствительна к локали, а это значит, что описания сигналов будут представлены на местном языке.

Функция psignal выводит (в stderr) строку, соотв аргументу msg, добавляет двоеточие, затем выводит описание сигнала sig. Как и функция strsignal, функция psignal чувствительна к локали.

Несколько сигналов описываются структурой данных под названием набор сигналов, которая представлена системным типом данных sigset_t.

Функция sigemptyset инициализирует набор сигналов, не содержащий членов. Функция sigfillset инициализирует набор сигналов, содержащий все сигналы (в томм числе все сигналы реального времени).

Для инициализации набора сигналов ДОЛЖНА быть использована одна из этих функций. Это необх потому, что язык С не иниц автоматические переменные, а инициализация статическим переменных нулем, вероятно, не может считаться надежным способом указания пустого набора сигналов, так как наборы сигналов могут быть реализованы посредством структур, отличных от битовых масок.

После инициализации отдельные сигналы могут быть добавлены в набор с помощью функции sigaddset и удалены - с помощью sigdelset.

Функция sigismember проверяет, является ли данный сигнал членом набора.

Для каждого процесса ядро хранит сигнальную маску - набор сигналов, доставка которых в процесс временно заблокирована. Если в процесс отправляется заблокированный сигнал, то доставка этого сигнала откладывается до тех пор, пока сигнал не будет разблокирован путем удаления из сигнальной маски процесса.

Мы можем использовать функцию sigprocmask для изменения сигнальной макси процесса, для получения существующей маски либ для совершения обоих действий.

Попытки заблокировать сигналы SIGKILL и SIGSTOP игнорируются без оповещения. Если мы попытаемся заблокировать эти сигналы, функция sigprocmask не только не даст доступа к ним, но и не сгенерирует ошибку.

Если процесс получает сигнал, который в данный момент подлежит блокированию, то он добавляется в набор ожидающих сигналов. Для определения того, какие сигналы процесса находятся в режиме ожидания, мы можем вызвать функцию sigpending.

Если диспозиция ожидающего сигнала изменяется, то при последующем разблокировании данный сигнал будет обработан в соответствии со вновь заданной диспозицией.

Набор ожидающих сигналов - это лишь маска, она показывает факт возникновения того ил иного сигнала, но не количество возникновений. Иными словами, если один и тот же сигнал был сгенерирован несколько раз, будучи заблокированным, то он записывается в набор ожидающих сигналов, а затем доставляется, но лишь однажды (одно из различий между станд сигналами и сигналами реального времени заключается в том, что вторые ставятся в очередь, как описано в разделе 22.8).

Даже если процесс не блокирует сигналы, он может получить сигналов меньше, чем было отправлено. Это может произойти, если сигналы отправляются настолько быстро, что они прибывают до того, как выполнение получающего сигнала процесса может быть запланировано ядром.  В результате, множественные сигналы записываются в набор ожидающих сигналов процесса лишь однажды.

Из миллиона отправленных сигналов только 52 были перехвачены процессом-получаетелем. Точное количество перехваченных не заблокированных сигналов будет варьироваться в зависимости от причуд алгоритма планирования ядра. Причина этого заключается в том, что каждый раз когда программа-отправитель запускается по плану, она отправляет получаетелю несколько сигналов. Однако только один из этих сигналов помечается как ожидающий и доставляется лишь тогда, когда у получателя есть возможность запуститься.

Системный вызов sigaction является альтернативой функции signal в части установки диспозиции сигнала.

Вызов функции pause приостанавливает выполнение процесса до тех пор, пока вызов не будет прерван обработчиком (или до тех пор, пока необрабатываемый сигнал не завершит процесс).

Сигнал может быть от процессу из ядра, из другого процесса или из самого себя.

Доставка сигнала, как правило, асинхронна, а это означает, что невозможно предсказать, в какой точке сигнал прерывает выполнение процесса.

Предпочтительнее писать простые обработчики сигналов. Одна из важных причин для этого - уменьшение вероятности создания состояний гонки. 

Чаще всего встречаются след две схемы обработчиков:
1) обработчик сигнала устанавливает глобальный флаг и завершается
2) обработчик сигнала производит некоего рода чистку

Доставка сигнала блокируется на время выполнения его обработчика.

Тот факт, что сигналы могут "исчезать", определенным образом влияет на проектирование обработчиков сигналов. Начать следует с того, что возможности то что возможности точно подсчитать количество раз, когда сигнал был сгенерирован, нет. 

Не все системные вызовы и библиотечные функции могут быть безопасно вызваны из обработчика сигнала. Чтобы понять почему, необходимо объяснить две концепции: реентерабельные функции и функции, безопасные для асинхронных сигналов.

ЦПУ обрабатывает инструкции одного логического потока выполнения программы.
 В многопоточных программах присут несколько независимых и параллельных (concurrent) логических потоков в рамках одного процесса.

Понятие многопоточного выполнения также имеет отношение к программам, в которых используются обработчики сигналов. Поскольку обработчик сигнала может асинхронно прервать выполнение программы в любой момент времени, основная программа и обработчик сигнала, по сути, формируют два независимых (хотя и не параллельных) потока в рамках одного процесса.

Функция называется реентерабельной в том случае, если она может одновременно безопасно выполняться несколькими потоками в рамках одного процесса.

Семейство функция malloc и другие библиотечные функции, которые применяют их, являются НЕреентерабельными.

Другие функции являются нереентерабельными, потомучто они возвращают информацию, используя статически выделенную память.

Функции могут быть нереентерабельными, если они используют для внутренних операций статические структуры данных. Самыми очевидными примерами могут быть члены библиотеки stdio, которые обновляют внутренние структуры данных для буферизированного ввода-вывода.

Если обработчик событий обновляет глобальные структуры данных, определенные программистом, обновляемые также из основной программы, то мы можем сказать, что обработчик событий является нереентерабельным по отношению к основной программе.

Если функция является нереентерабельной, то страница справочника, как правило, будет содержать явное или неявное указание на это.

Функция, безопасная для асинхронных сигналов, - это такая функция, реализация которой гарантирует безопасность при вызове из обработчика. Функция может быть безопасной для асинхронного сигнала либо благодаря тому, что она реентерабельна, либо потому, что она непрерываема обработчиком.

При написании обработчиков сигналов у нас есть две альтернативы:
1) Убедиться, что сам код обработчика является реентерабельным и что из него вызываются только функции, безопасные для асинхронных сигналов.
2) Блокировать доставку сигналов во время выполнения кода основной программы, вызывающей небезопасную функцию или работающую с глобальной структурой данных, также обновляемой обработчиком сигнала.

Поскольку функции, перечисленные в табл. 21.1, могут обновлять переменную errno, их применение может все таки превратить обработчик сигнала в нереентерабельный, так как данные функции могут перезаписать значение переменной ernno, установленное основной программой. Обойти проблему можно путем сохранения текущего значения переменной errno на входе в обработчик сигнала и восстановление значения на выходе из обработчика.

В приложениях, применяемых на практике, следует избегать вызова небезопасных функций из тела обработчиков сигналов.

Если обработчик сигнала получает доступ к глобальным переменным (флагу), то мы должны всегда объявлять эти переменные с использованием ключевого слова volatile, дабы запретить компилятору выполнять оптимизацию, результатом которой может стать хранение переменной в регистре.

Стандарты языка С, а также стандарт SUSv3 устанавливают целочисленный тип данных sig_atomic_t, чтение и запись экземпляров которого гарантированно являются атомарными. Обратите внимание, что операторы С инкремента и декремента не попадают в гарантию, предоставляемую типом данных sig_atomic_t.

Все рассмотренные до этого момента обработчики сигналов завершаются возвратом в основную программу. Однако простой возврат из обработчика не всегда является желательным, а в некоторых случаях может быть и бесполезным.
Существуют другие различные методы завершения работы обработчика сигнала.
1) Вызов функции _exit для завершения процесса.
2) Вызов функции kill или raise для отправки сигнала, аварийно завершающего процесс.
3) Выполнение нелокального перехода из обработчика.
4) Вызов функции abort.

Функция exit небезопасна для вызова в обработчике, так как сбрасывает буферы stdio перед осуществлением вызова функции _exit.

При использовании стандартной функции longjmp для выхода из обработчика сигнала возникает проблема. Ранее уже было отмечено, что после входа в обработчик ядро автоматически заносит активирующий его сигнал, так же как и любой другой указанный в поле act.sa_mask, в сигнальную маску процесса, а затем удаляет эти сигналы из маски, когда обработчик выполняет нормальный возврат. Но что случается с сиг маской, когда мы выходим из обработчика с помозью функции longjmp? Ответ зависит от происхождения конкретной реализации UNIX. Из за этой разницы между двумя основными вариантами UNIX, комитет по подготовке стандарта POSIX.1-1990 решил не включать в него способ обработки сигнальной маски функциями setjump и longjump. Вместо этого комитет определил две новые функции - sigsetjump и siglongjump, предоставляющие явный контроль над сигнальной маской при выполнении нелокального перехода.

Функция abort завершает процесс и заставляет его создать файл дампа ядра.

Если функция abort успешно завершает процесс, то она также сбрасывает и закрывает потоки stdio.

В случае, если размер стека процесса достигает своего максимума (или очень близок) к нему, при генерации сигнала у ядра может не получится выделить участок на стеке процесса, что приведет к поведению процесса по умолчанию. Чтобы в вышеупомянутой ситуации происходила обработка сигнала SIGSEGV, мы можем поступить следующим образом:
1) выделить участок памяти, называемый альтернативным сигнальным стеком, который можно использовать в качестве кадра стека для обработчика сигнала.
2) применить системный вызов signalstack для информирования ядра о наличии альтернативного сигнального стека.
3) при установке обработчика сигнала указать флаг SA_ONSTACK, чтобы информировать ядро о том, что кадр для данного обработчика должен быть создать на альтернативном стеке.

Как правило, место для альтернативного сигнального стека выделяется либо статически, либо динамически на куче.

Ядро не изменяет размер альтернативного сигнального стека.

Флаг SA_SIGINFO при установке обработчика с помощью функции sigaction позволяет обработчику получать дополнительную информацию о полученном сигнале. В следствии этого сигнатура обработчика сигнала претерпевает изменения.

Даже если мы воспользуемся макросом, подобным NO_EINTR, настройка прерывания обработчиками сигналов системных вызовов может быть затруднительна, так как мы должны будем добавить программный код перед каждым блокирующим системным вызовом. Вместо этого мы можем указать флаг SA_RESTART при установке обработчика с помощью функции sigaction. Такой системный вызов будет автоматически перезапущен ядром от имени процесса. Это значит, что нам не нужно самим обрабатывать возможный возврат с ошибкой EINTR для данных системных вызовов.

К сожалению, не все блокирующие системные вызовы автоматически перезапускаются в результате установки флага SA_RESTART. Отчасти причины этому исторические.

Системные вызовы ввода-вывода прерываемы, и, следовательно, автоматически перезапускаются с помощью флага SA_RESTART только при работе на "медленных" устройствах. К медленным устройкствам относятся терминалы, конвейеры, именованные каналы FIFO и сокеты. Для файлов этих типов различные операции ВВ могут блокироваться. (Напротив: дисковые файлы не попадают в эту категирию медленных устройств, так как операции ВВ дисков обычно могут быть незамедлительно незамедлительно выполнены через буферный кеш ядра. Если требуется дисковый ввод\вывод, то ядро переводит процесс в состояние сна до тех пор, пока не завершится операция ВВ).

Если требуется дисковый ВВ, то ядро переводит процесс в состояние сна до тех пор, пока не завершится операция ВВ (перекрытие ВВ).

Функция siginterrupt изменяет установку SA_RESTART конкретного сигнала.

К сожалению, не все блокирующие системные вызовы автоматически перезапускаются в результате установки флага SA_RESTART. Отчасти причины этому исторические.

Системные вызовы ввода-вывода прерываемы, и, следовательно, автоматически перезапускаются с помощью флага SA_RESTART только при работе на "медленных" устройствах. К медленным устройкствам относятся терминалы, конвейеры, именованные каналы FIFO и сокеты. Для файлов этих типов различные операции ВВ могут блокироваться. (Напротив: дисковые файлы не попадают в эту категирию медленных устройств, так как операции ВВ дисков обычно могут быть незамедлительно незамедлительно выполнены через буферный кеш ядра. Если требуется дисковый ввод\вывод, то ядро переводит процесс в состояние сна до тех пор, пока не завершится операция ВВ).

Если требуется дисковый ВВ, то ядро переводит процесс в состояние сна до тех пор, пока не завершится операция ВВ (перекрытие ВВ).

Функция siginterrupt изменяет установку SA_RESTART конкретного сигнала.

В Linux некоторые блокирующие системные вызовы могут возвращаться ошибку EINTR даже при отсутствии обработчика сигнала. Это может случиться, если системный вызов заблокирован и процесс сначала оставлен сигналом, а замем возобновлен сигналом SIGCONT.

Результатом такого поведения является то, что если существует вероятность того, что наша программа может быть остановлена и перезапущена сигналами, значит, нам может потребоваться включить в нее программный код для перезапуска вышеперечисленных системных вызовов, даже если в программе не устанавливаются обработчики сигналов остановки.

^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
"If a signal handler is invoked while a system call or library function call is blocked, then either:
1) the call is automaticall restarted after the signal handler returns; or
2) the call fails with the error EINTR"

Когда ОБРАБОТЧИК СИГНАЛА прерывает заблокированный системный вызов, этот системный вызов завершается с ошибкой EINTR.

Установка обработчика сигнала с помощью функции sigaction с флагом SA_RESTART приводит к автоматическому перезапуску многих (но не всех) системных вызовов.

Некоторые сигналы заставляют процесс создать файл дампа ядра и завершиться. Дамп ядра - это файл, содержащий образ памяти процесса на момент его завершения.

Одним из способов заставить программу создать файл дампа ядра является ввод символа "выход" (обычно Cntl + \), вызывающего генерацию сигнала SIGQUIT.

Начиная с версии 2.6.23 характерный для Линукс файл /proc/PID/coredump_filter может для каждого процесса определить, какого рода отображения памяти записываются в файл дампа ядра.

Начиная с Линукс 2.6, строка формата, содержащаяся в характерном для Линукс файле /proc/sys/kernel/core_pattern, контролирует присвоение имен всем файлам дампа ядра, создаваемым в системе.

Для некоторых сигналов применяются особые правила доставки, задания диспозиции и обработки.

Невозможно изменить действие по умолчанию сигнала SIGKILL, который всегда завершает процесс и SIGSTOP, который всегда останавливает процесс. Обе функции, signal и sigaction возвращают ошибку при попытке изменить диспозицию этих сигналов. Эти сигналы не могут быть заблокированы. Запрет изменения действий этих сигналов по умолчанию означает, что они всегда могут быть использованы для завершения или остановки процесса, над которым был потерян контроль.

Сигнал SIGCONT используется для возобновления процесс, ранее остановленного одним из стоп сигналов. Из-за уникального предназначения в некоторых ситуациях ядро обрабатывает эти сигналы отлично от других.

При получении сигнала SIGCONT происходит удаление всех ожидающих процесса стоп-сигналов (иными словами, процесс их даже не видит). Напротив, при доставке любого стоп-сигнала происходит автоматическое удаление ожидающего сигнала SIGCONT.

Если на момент запуска программа обнаруживает, что диспозиция сигнала, генерируемого терминалом, была установлены равной SIG_IGN (игнорировать), то в большинстве случаев программа не должна изменять диспозицию такого сигнала.

Сигналы SIGBUS, SIGFPE, SIGILL и SIGSEGV могут быть сгенерированы вследствие аппаратного исключения или, что реже, путем отправки через функцию kill.
В случае аппаратного исключения SUSv3 устанавливает поведения процесса как неопределенное, если выполняется возврат из обработчика сигнала или если он блокирует или игнорирует сигнал.

Если сигнал был вызван аппаратным исключением, то программа пытается возобновить выполнение с той же инструкции, которая вызвала исключение. Наоборот, если сигнал был отправлен программно (например, kill.2), то после возврата из обработчика программа продолжает выполнение со следующей инструкции, так как никакого аппаратного исключения не было.

В игнорировании аппаратно генерируемого сигнала очень мало смысла, так как непонятно, каким образом программа должна продолжать выполнение в случае, например, арифметического исключения. При генерации одного из вышеперечисленных сигналов в результате аппаратного исключения Линукс доставляет этот сигнал в программу, даже несмотря на инструкцию игнорировать такие сигналы.

Как и в предыдущем случае, в блокировании сигнала очень мало смысла, так как непонятно, каким образом программа должна продолжать выполнение. В линукс 2.4 и более ранних версиях ядро просто игнорирует попытки заблокировать аппаратно генерируемый сигнал. Он доставляется в процесс в любом случае, а затем либо завершает процесс, либо перехватывается обработчиком, если таковой был установлен. Начиная с линукс 2.6, если сигнал заблокирован, то процесс всегда незамедлительно аварийно завершается этим сигналом, даже если для процесса установлен обработчик данного сигнала.

Правильным способом работы с аппаратно генерируемыми сигналами является либо принятие их действия по умолчанию, либо написания обработчиков, которые не выполняют нормальный возврат. Вместо выполнения нормального возврата обработчик может завершить выполнение вызовом функции _exit для завершения процесса либо вызовом функции siglongjump для гарантии того, что управление передается в некую точку программы, отличную от инструкции, вызвавшей генерацию сигнала.

Модель, которую мы до сих пор неявно подразумевали, называется асинхронной генерацией сигналов. В рамках ее сигнал посылается либо другим процессом, либо генерируется ядром при свершении события, не зависящего от выполняемого процесса (например, когда пользователь вводит символ прерывания). Для асинхронно генерируемых сигналов утверждение, что процесс не может предсказать, когда он получит сигнал, истинно. Однако в некоторых случаях сигнал генерируется во время выполнения процесса. Мы уже рассмотрели два примера таких ситуаций: аппаратно генерирумые сигналы, которые генерируются в результате выполнения конретного машинного кода, результатом выполнения которого является аппаратное исключение; процесс может использовать функции raise, kill, killpg для отправки сигналов самому себе.

В вышеописанных случаях генерация сигнала синхронная - сигнал доставляется моментально (если этот сигнал не заблокирован). Иными словами, утверждение о непредсказуемости доставки сигналов в данном случае неприменимо. Для синхронно генерируемых сигналов доставка предсказуема и воспроизводима.

"Когда процесс посылает сигнал самому себе, сигнал доставляется мгновенно."

Обратите внимание, что синхронность - это описание того, каким образом сигнал генерируется!, а не самого сигнала. Следовательно, все сигналы могут быть сгенерированы синхронно или асинхронно.

При асинхронной генерации сигнала может наблюдаться (небольшая) задержка во время нахождения его в режиме ожидания после генерации и перед фактической доставкой, даже если этот сигнал не заблокирован. Причиной этого является тот факт, что ядро доставляет в процесс ожидающий сигнал только при следующем переключении из режима ядра в режим пользователя во время выполнения данного процесса. На практике это означает, что процесс доставляется в один из следующих моментов:
когда процесс заново запланирован после предшествующего тайм-аута (то есть в начале тайм-слота).
по завершении системного вызова (доставка сигнала может привести к преждевременному завершению блокирующего системного вызова).

Если несколько сигналов ожидают доставки в процесс и были одновременно разблокированы функцией sigprocmask, то все эти сигналы будут назамедлительно доставлены в процесс. В текущих реализациях ядро Линукс доставляет сигналы в порядке возрастания. Впрочем, мы не можем всецело полагаться на то, что (стандартные) сигналы будут доставляться в какой то очередности, так как согласно стандарту SUSv3 очередность доставки нескольких сигналов зависит от реализации системы. (Это высказывание действительно только для стандартных сигналов). В случаях, когда несколько разблокированных сигналов ожидают доставки, если переключение между режимами ядра и пользователя происходит во время выполнения обработчика, то выполнение этого обработчика будет прервано активацией второго обработчика сигнала (и т.д). 

Ранние реализации сигналов были ненадежными (см. стр. 479).

В добавок к ненадежности ранние версии UNIX не предоставляли автоматический перезапуск системных вызовов.

Релизация функции signal в glibc изменялась с течением времени несколько раз. В современных версиях (glibc 2 >=) по умолчанию предоставляется новая семантика. В старых версиях библиотеки дается более ранняя ненадежная (совместимая с System V) семантика.

Если мы хотим получить ненадежные семантики сигналов в совр версиях библиотеки glibc, то мы можем явно заменить наши вывозы функции signal вызовами (нестандартной) функции sysv_signal.

Надежные сигналы 4.2BSD сняли эти ограничения, чему также последовали некоторые другие реализации UNIX. Однако старая семантика сохраняется и сегодня в реализации функции signal в System V, более того, в современных стандартах, таких как SUSv3 и C99, эти аспекты намеренно не специфированы.

Из за вышеописанных проблем переносимости между ОС System V и BSD (старые и современные версии библиотеки glibc) лучшим подходом всегда является использование функции sigaction, а не signal для установки обработчиков сигналов.

Стоит заметить, что код будет переносимее (и короче) при использовании функции signal для установки диспозиции по умолчанию сигналов SIG_IGN и SIG_DFL;

Сигналы реального времени были определены в стандарте POSIX.1b для устранения ограничений, накладываемых стандартными сигналами. (481)

В отличие от стандартных сигналов, сигналы реального времени не определяются отдельными константами.

Стандарт SUSv3 не требует, чтобы значения констант SIGRTMIN и SIGRTMAX были представлены обычными целыми числами. Значения этих констант могут быть определены как функции (как это просходит в Linux).

Константа _POSIX_SIGQUEUE_MAX устанавливает минимальный верхний предел количества сигналов реального времени в очереди.

Сигнал реального времени также может быть послан с помощью функций kill, killpg и raise. Однако стандарт SUSv3 оставляет авторам реализации решать, возможно ли постановка в очередль сигналов реального времени, отправляемых с помощью вышеперечисленных интерфейсов.

Системный вызов sigqueue посылает сигнал реального времени, указанный в атрибуте sig, в процесс, указанный в атрибуте pid.

Для отправки сигнала с помощью этой функции требуются те же разрешения, что и при использовании функции kill. Можно отправить нулевой сигнал - такая операция несет тот же смысл, что и вызов kill.

В аргументе value указываются данные, сопровождающие сигнал.

Поле sival_ptr редко используется вместе с функцией sigqueue, так как указатель, полученный в одной процессе, редко имеет какой то смысл в другом. Однако это поле задействуется в других функциях, в которых применяются объединения sigval, как мы увидим при рассмотрении таймеров POSIX и очередей сообщений POSIX.

Мы можем обрабатывать сигналы реального времени так же, как и стандартные сигналы: с помощью нормального обработчика с одним аргументом. Кроме того, мы также можем обрабатывать сигналы реального времени с помощью обработчика с тремя аргументами, устанавливаемого посредством флага SA_SIGINFO. В последней случае, значение, передаваемое посредством сигнала будет храниться в структуре siginfo_t, в поле si_value. Оно равно значению value, которое было предоставленно отправителем при вызове sigqueue.

Доставка сигналов реального времени упорядочивает доставку по номеру сигнала (от меньшего к большему). В случае, если несколько сигналов имеют одинаковый номер, они доставляются в порядке прибытия.

В случае состояния гонки (состязательной ситуации) между основной программой и собственным обработчиком сигнала, от нас требуется использование автоматического разблокирования сигнала и  приостановки процесса. В этом и есть предназначение системного вызова sigsuspend.

Системный вызов sigwaitinfo используется для реализации синхронного приема сигнала. Она приостанавливает выполнение процесса до тех пор, пока из набора, указываемого аргументом set, не будет ожидать по крайней мере один сигнал.

Ожидание сигналов с использованием функции sigwaitinfo не только избавляет от лишнего кода при написании обработчиков сигналов, но и является несколько более быстрым решением по сравнению с сочетанием "обработчик сигнала + функция sigsuspend".

Системный вызов sigtimedwait - это вариация функции sigwaitinfo. Единственное отличие заключается в том, что функция sigtimedwait позволяет ограничить время ожидания.

Начиная с версии ядра 2.6.22, в Linux предоставляется (нестандартный) системный вызов signalfd, создающий специальный файловый дескриптор, из которого можно прочитать сигналы, направляемые в вызывающий участок кода. Механизм signalfd предоставляет альтернативу функции sigwaitinfo для синхронного приема сигналовпозволяет ограничить время ожидания.

Начиная с версии ядра 2.6.22, в Linux предоставляется (нестандартный) системный вызов signalfd, создающий специальный файловый дескриптор, из которого можно прочитать сигналы, направляемые в вызывающий участок кода. Механизм signalfd предоставляет альтернативу функции sigwaitinfo для синхронного приема сигналов.

С одной точки зрения мы можем рассматривать сигналы как форму межпроцессного взаимодействия (IPC). Однако в таком виде сигналы страдают от большого количества ограничений. Во первых, по сравнению с другими метода взаимодействия процессов, которые мы рассматриваем в следующий главах, программирование на сигналах сложно и громоздко. Этому есть следующие причины:
1) асинхронная природа сигналов.
2) стандартные сигналы не ставятся в очередь.
3) возможность передачи только ограниченного объема информации: номер сигнала и - в случае с сигналами реального времени - слово (целое число или указатель) дополнительных данных. Эта низкая пропускная способность делает сигналы медленными по сравнению с другими методами IPC, например такими, как каналы.

По причине вышеперечисленных ограничений сигналы редко используются для реализации межпроцессного взаимодействия. !!!!!!!

Обратите внимание, что в нашем обсуждении мы сосредоточились на API сигналов POSIX.

Сигнал может быть сгенерирован синхронно и асинхронно. Асинхронная генерация происходит, когда сигнал отправляется процессу ядром или другим процессом. Процесс не может точно предсказать, когда в него будет доставлен сигнал, сгенерированный асинхронно. Синхронная генерация происходит, когда сам процесс выполняет код, напрямую генерирующий сигнал. Доставку сигнала, генерируемого синхронно, можно предсказать с высокой точность (она происходит мгновенно).

Сигналы реального времени - надстройка POSIX на исходную модель сигналов. Сигналы реального времени предназначены для использования в целях, определяемых приложением.

Системный вызов sigsuspend позволяет программе автоматически изменять сигнальную маску процесса и приостанавливать выполнение до прибытия сигнала.

Чаще всего, сигналы используются для синхронизации процессов и для других целей (например, оповещение о событии, управление заданиями, истечение таймера).

Сигналы играют важную роль в различных частях API системных вызовов. Кроме того, некоторые функции, связанные с сигналами, также характерны для потоков.

сигнальная маска для этого сигнала блокирует не сам сигнал, а его обработчик? и потому как сигнал этот доставляется всегда, обработчик запускается только после разблокировки маски (SIGCONT).

/////////////////Зарезервированно для главы 23 "Таймеры и переход в режим сна"//////





////////////////////////////////////////////////////////////////////////////////////

Основными элементами этой и нескольких следующих глав являются системные вызовы fork, exit, wait, execve. Каждый из них имеет свои вариации.

Системный вызов fork позволяет одному процессу, родителю, создавать новый, дочерний процесс. Оба этих процесса являются (почти) идентичными: потомок получает копии родительского стека, данных, кучи и текста. Термин fork стали применять потому, что родительский процесс как бы делиться на две копии самого себя.

Библиотечная функция exit завершает процесс, делая все его ресурсы доступными для последующего перераспределения ядром. (exit - обертка над системным вызовом _exit). Обычно с помощью вызова exit завершают работу только одного родителя или потомка, порожденного вызовом fork; остальные процессы следует завершать с помощью вызова _exit.

Системный вызов wait имеет два назначения. Во первых, если работа потомка текущего процесса еще не была завершена путем вызова exit, функция wait приостанавливает выполнение родителя, пока не будет завершен один из его потомков.

Системный вызов execve загружает в память процесса новую программу.
Текст сущ программы сбрасывается, а для новой программы заново создаются сегменты со стеком, данными и кучей. Эту операцию часто называют выполнением новой программы.

В некоторых других операционных системах возможности функций fork и exec объединены в одну операцию - порождение (spawn).

Имейте ввиду, что системных вызовов или библиотечных функция с именем exec не существует.

Стандарт SUSv3 предусматривает дополнительную функцию posix_spawn, которая объединяет возможности fork и exec.

Ключевым моментом в понимании вызова fork является тот факт, что после завершения его работы мы получаем два процесса, каждый из которых продолжает выполнение с момента возврата из этого вызова.

Распознавать процессы внутри кода программы можно с помощью значения, возвращенного функцией fork (-1 при ошибке).

Следует понимать, что после вызова fork невозможно сказать, какой из двух процессов первым получит от планировщика ресурсы ЦП.

Когда выполняется вызов fork, потомок получает копии всех файловых дескрипторов родителя. Эти копии создаются в той же манере, как работает функция dup. Следствием из этого является то, что все атрибуты файловой дескрипции являются общедоступными как для родительского, так и для дочернего процесса (файловое смещение, флаги состояния...).

Если вам не требуется такое совместное использование атрибутов файлов, приложение должно быть спроектировано так, чтобы родитель и потомок после вызова fork использовали разные дескрипторы, сразу же закрывая те из них, которые были получены из другого процесса (если один из процессов выполняет exec, вам также может пригодиться флаг FD_CLOEXEC).

Большинство современных реализаций UNIX, в том числе и Linux, пытаются избежать избыточного копирования данных при создании дочернего процесса  с помощью fork, используя две методики: общедоступная память для чтения (сегмент кода) и копирование при записи.

Мы можем сочетать использование вызовов fork и wait, чтобы контролировать изменение объема занимаемой процессом памяти. Они позволяют нам изолировать изменения памяти в дочернем процессе, что может быть полезно для предотвращения утечек памяти, фрагментации кучи и т.д.
 (spawn).

 Имейте ввиду, что системных вызовов или библиотечных функция с именем exec не существует.

 Стандарт SUSv3 предусматривает дополнительную функцию posix_spawn, которая объединяет возможности fork и exec.

 Как и fork, вызов vfork применяется вызывающим процессом для создания нового потомка. Однако он специально был спроектирован так, чтобы его можно было использовать в программах, в которых дочерний процесс сразу же делает вызов exec. Функция vfork имеет два отличия от системного вызова fork, которые делают ее более эффективной:
 1) страницы вирт памяти или таблицы страниц не дублируются для доч проц. Вместо этого потомок и родитель делят память до тех пор, пока один из них не выполнит успешный вызов exec или _exit, чтобы завершить работу. (процесс, созданный vfork содержит страницы памяти, ссылающиеся на страницы памяти родительского процесса).
 2) выполнение родительского процесса приостанавливается до тех пор, пока потомок не вызовет exec или _exit.

 Семантика функции vfork  указывает на то, что после ее вызова потомок гарантированно получит ресусы ЦП раньше родителя (в отличии от fork, который не дает никаких гарантий).

 Везде, где используется vfork, сразу после нее обычно должен следовать вызов exec для предотвращения невиданных чудес.

Приложения, которые явно или неявно полагаются на определенный порядок выполнения для получения корректных результатов, подвержены ошибкам, связанным с состоянием гонки. Такие ошибки может быть трудно выявить, потому что их возникновение зависит от того, как ядро планирует выполнение процессов под той или иной нагрузкой. Отладка таких ошибок в масштабный программах может оказаться довольно сложной.

Бывает, что после вызова fork одному из процессов нужно подождать, пока не завершится другой. В этом случае после окончания работы активный процесс может послать сигнал, ожидаемый другим процессом.

Системный вызов vfork является более эффективной версией fork, но из за необычной семантики его лучше избегать.

Обычно процесс можно завершить двумя способами. Во первых, это аварийное завершение, вызванное передачей сигнала, чьим действием по умолчанию является остановка работы процесса (со сбросом дампа памяти или без). Возможно также нормальное завершение с помощью системеного вызова _exit.

Аргумент status имеет тип int, однако родительскому процессу доступны только последние 8 бит.

Стандарт SUSv3 определяет две константы, EXIT_SUCCESS(0) и EXIT_FAILURE(1).

Программы обычно не вызывают _exit напрямую, используя вместо этого библиотечную функцию exit, которая выполняет различные предварительные действия, такие как: вызываются обработчики выхода, сбрасываются буферы stdio, выполняется системный вызов _exit.

Вызов _exit характерен для UNIX систем.

Другим способом завершения работы процесса является возвращение из функции main(), явное или неявное (когда достигается конец функции). Явный возврат значения (return n) обычно является эквивалентом вызова exit(n), поскольку среда выполнения, которая вызывает функцию main(), использует возвращаемое из нее значение для вызова exit().

Возвращение из функции без указывания значения или просто завершение главной функции тоже приводит к тому, что программа, вызвавшая функцию main(), выполняет вызов exit(), однако результат при этом зависит от поддерживаемого стандарта языка С и использованных параметров компиляции.

Подробности завершения процесса на 550 стр.

Обработчик выхода - это функция, предоставляемая программистом, которая регистрируется на каком то этапе жизненного цикла процесса и затем автоматически вызывается во время его нормального завершения посредством функции exit.
 (игнорируются при _exit или если процесс аварийно завершается с помощью сигнала.)

SIGTERM > SIGKILL.

В glibc предусмотрено два способа регистрации обработчиков выхода. Первый из них описан в стандарте SUSv3 и заключается в использовании функции atexit.

При выхове программой exit эти функции выполняются в порядке, обратном их регистрации.

SUSv3 гласит, что в случае, если обработчик выхода сам вызывает exit, результат становиться неопределенным.

Также этот стандарт требует, чтобы процесс мог зарегистрировать как минимум 32 обработчика выхода. (sysconf(_SC_ATEXIT_MAX)).

Дочерний процесс, созданный с помощью вызова fork, наследует копию списка зарегистрированных обработчиков выхода своего родителя. Когда процесс выполняет функцию exec, все обработчики удаляются (это необходимо, потому что функция exec заменяет код обработчиков выхода вместе с остальным программным кодом).

У обработчиков, зарег с помощью atexit, есть два ограничения. 1) Он не знает, какой код был передан в функцию exit. Иногда это может быть полезно. 2) Мы не можем указать аргумент для вызываемого обработчика.

Для обхода этих ограничений библиотека glibc предоставляет альтернативный (нестандартный) способ регистрации обработчиков выхода: вызов on_exit.

Функции, зарегистрированные с помощью вызовов atexit и on_exit, попадают в один и тот же список.

Буферы stdio находятся в пользовательском пространстве памяти. Следовательно, эти буферы дублируются в дочернем процессе вызовом fork. Когда стандартный вывод направлен в терминал, буферизация в нем по умолчанию происходит построчно, благодаря чему строки, разделенные разрывами, сразу же выводятся вызовом printf. Однако стандартный вывод, направленный в файл, по умолчанию буферизируется по блокам.

В приложении, создающем потомка, который не выполняет новой программы, обычной только один из процессов (чаще всего родитель) должен завершаться с помощью функции exit, тогда как для всех остальных следует использовать вызов _exit (это связано с дублированием буферов stdio и их буферизацией (см. стр. 555). Это дает гарантию того, что только один процесс вызывает обработчики выхода и сбрасывает буферы stdio, что обычно и требуется.

Вывод вызова write не дублируется, поскольку данные этого вызова передаются напрямую в буфер ядра, который не подлежит копированию во время выполнения функции fork.

Аварийное завершение процесса происходит в результате получения определенных сигналов. Некоторые из них заставляют сгененерировать файл дампа памяти.

Нормальное завершение выполняется с помощью вызова exit (_exit).

Что бы ни послужило причиной завершения процесса, ядро предпринимает различные шаги по освобождению ресурсов.

Во многих приложениях, в которых создаются вложенные процессы, бывает полезно наделить родителя возможностью следить за своими потомками, чтобы знать, когда и как они завершают свою работу. Эта возможность реализована в виде ряда системных вызовов, основным из которых является wait.

Сис вызов wait ждет, когда один из потомков вызывающего процесса прекратит работу и возвращает код завершения этого дочернего процесса через буфер, на который указывает аргумент status.

Вызов wait возвращает идентификатор завершившегося дочернего процесса.

Если в какой то момент у вас имеется несколько завершенных потомков, порядок, в котором они будут обработаны вызовами wait, является неопределенным (согласно стандарту SUSv3). Это означает, что порядок обработчик зависит от реализации. Он может меняться даже в разных версиях ядра Линукс.

Системный вызов waitpid снимает ряд ограничений, присущих вызову wait:
1) если родительский процесс создал несколько потомков, wait не позволяет лжидать завершения конкретного из них; мы можем отслеживать завершение работы только следующего дочернего процесса.
2) если ни один из потомков еще не был завершен, вызов wait всегда блокируется. Иногда имеет смысл организовать неблокирующее ожидание, чтобы, если все потомки все еще работают, иметь возможность немедленно узнать об этом факте.
3) с помощью wait можно отслеживать только потомки, которые завершились. Если потомок был остановлен или возобновил свою работу, мы об этом не узнаем.

Значение status используется для получение информации о потомке. Оно является битовой маской и способ ее заполнение определяет событие, произошедшее с потомком. Детали заполнения не стандартизированны и для переносимости необходимо использовать специальные макросы проверки.

Обратите внимание, что хотя макросы тоже используют для своих аргументов имя status, они ожидают получить обычное целое число, а не указатель на него, как в случае с вызовами wait и waitpid.

Если потомку нужно сообщить, что он завершается из за сигнала, его обработчик должен сначала себя отключить, и затем еще раз послать тот же сигнал, которому уже ничто не помешает завершить работу процесса.

Как и waitpid, вызов waitid возвращает статус дочернего процесса. Однако, кроме этого, он предоставляет дополнительные возможности, недоступные в waitpid. Он происходит из System V, хотя и не является частью стандарта SUSv3.

Главным отличием вызова waitid от waitpid является то, что он предоставляет более тонкий контроль за событиями ожидаемого потомка. Это достигается за счет параметра битовой маски options.

Системные вызовы wait3 и wait4 своим назначением похожи на waitpid. Однако принципиальная их семантическая особенность заключается в том, что в структуре, на которую указывается аргумент rusage, они возвращают сведения об использовании ресурсов завершенным потомком. Оба этих системных вызова берут свое начало из системы BSD.

Жизненные циклы родительского и дочернего процессов обычно не совпадают.

Родителем "осиротевшего" потомка становиться процесс init - предок всех процессов.

Что происходит с потомком, который завершается до того, как его родитель имел возможность выполнить wait? Дело в том, что, хотб потомок и закончил свою работу, родителю все равно должно быть позволено сделать вызов wait, чтобы определить причину завершения. Ядро решает эту проблему путем превразщения потомка в "зомби". Это означает, что большинство ресурсов, занимаемых потомком, возвращаются системе и могут быть задействованы другими процессами. Единственная часть дочернего процесса, которая остается нетронутой - это запись в таблице процессов ядра, хранящая (помимо прочего_ идентификатор потомка, код завершения и статистику использования ресурсов.

Процесс зомби нельзя убить сигналом, даже если это SIGKILL. Благодаря этому родитель может всегда выполнить вызов wait.

Когда родитель наконец делает вызов wait, ядро удаляет процесс зомби, поскольку информация о нем больше не требуется. С другой стороны, если родитель завершает работу, так и не выполнив вызов wait, процесс init удочеряет потомка и автоматически делает этот вызов самостоятельно, удаляя таким образом "зомби" из системы.

ps обозначает процесс зомби с помощью строки "<defunct>".

Принудительное завершение дочернего процесса - это событие, которое происходит асинхронно.

Сигнал SIGCHLD передается родительскому процессу всякий раз, когда один из его потомков завершает работу. По умолчанию он игнорируется, но мы можем его перехватить, установив соответствующий обработчик.

Представьте, что на момент установки обработчика SIGCHILD у процесса уже есть завершенный потомок. Должно ли ядро немедленно сгенерировать сигнал SIGCHILD для родителя? Стандарт SUSv3 оставляет этот вопрос без ответа. Одни системы, в основном на базе System V, генерируют этот сигнал, а другие, включая Linux - нет. Переносимое приложение может нивелировать эти отличия, установив обработчик SIGCHILD до создания каких либо потомков (обычно это наиболее очевидное решение).

По аналогии с тем, как вызов waitpid может быть использован для отслеживания остановленных потомков, родитель может получать сигнал SIGCHLD в случае остановки одного из его дочерних процессов (тоже по сигналу). Этого можно добиться с помощью флага SA_NOCLDSTOP, когда вызов sigaction устанавливает обработчик SIGCHLD.

Существует еще один способ работы с завершенными процессами. Явное изменение диспозиции сигнала SIGCHLD на SIG_IGN приводит к тому, что любой потомок, который впоследствии завершает работу, немедленно удаляется из системы, вместо того чтобы превратиться в "зомби". Стоит отметить, что, хотя диспозицией сигнала SIGCHLD по умолчанию является игнорирование, явная установка диспозиции SIG_IGN приводит к описанному выше поведению, отличного от поведения по умолчанию. SIGCHLD - единственный сигнал, который ведет себя таким образом.

В Linux, как и во многих реализациях UNIX, изменение диспозиции сигнала SIGCHLD на SIG_IGN не влияет на статус УЖЕ ИМЕЮЩИХСЯ потомков "зомби", которых по прежнему нужно ждать.

Использование вызовов wait и waitpid (и других связанных с ними функций) позволяет родительскому процессу получать статус его завершенных и остановленных потомков.

Когда завершается дочерний процесс, он становится «зомби» и удаляется из системы только после того, как его родитель получит его статус с помощью вызова wait() (или аналогичного).

Системный вызов execve загружает в память процесса новую программу. Во время этой операции старая программа удаляется вместе со стеком, данными и кучей и заменяется аналогичными частями новой программы.

Системный вызов execve задействуется в качестве основы для различных библиотечных функций, имена которых начинаются с exec.

Linux предоставляет файл /proc/PID/exe, который является символьной ссылкой и содержит абсолютный путь к исполняемому файлу, запущенному соответствующим процессом.

После вызова execv идентификатор процесса остается неизменным, поскольку сам процесс продолжает существовать.

Поскольку в случае успеха вызов execve заменяет вызвавшую его программу, он никогда не возвращает значения.

Все библиотечные функции exec* работают поверх вызова execve.

exec* (l - list, v - vector, p - PATH, e - environment).

При входе в систему значение PATH настраивается общесистемными и пользовательскими скриптами. Поскольку потомок наследует копию переменных среды своего родителя, каждый процесс, создаваемый командной оболочкой для выполнения команды, получает дубликат переменной PATH из оболочки.

Если переменная PATH не определена, функции execvp и execlp по умолчанию используют список путей вида: .:/usr/bin:/bin.

При передаче вызову execlp (и любой другой функции exec, использующей переменную среды PATH) имени файла (то есть строки без слешей), он выдает ошибку, если такой файл не встретился ни в одном каталоге переменной PATH. С другой стороны, если передать этим функция путь, содержащий один или несколько слешей, содержимое PATH будет проигнорировано.

С версии 2.3.2 библиотека glibc предоставляет функцию fexecve, которая похожа на execve, но позволяет указать исполняемый файл в виде дескриптора fd, а не с помощью пути к файлу.

Интерпретатор - это программа, которая считывает и выполняет текстовые команды (в отличии от компилятора, транслирующего исходный код в машинных, который затем может быть выполнен процессором или виртуальной машиной).

Обычно интерпретаторы позволяюбт считывать и выполнять команды не только в интерактивном режиме, но и путем загрузки их из текстового файла, который называется скриптом (или сценарием).

Ядра в системах UNIX позволяют запускать интерпретируемые скрипты тем же способом, что и скомпилированные программы. Для этого должно выполняться два условия: во первых, файл скрипта должен быть исполняемым и, во вторых, в начале файла должна находиться строка, в которой указан путь к подходящему интерпретатору. Эта строка имеет следующий вид:
#!(шебанг) путь-к-интерпретатору [ опциональные аргументы ]

Скрипты командной строки в UNIX - shell скрипты.

В ядре Linux существует ограничение на длину начальной строки скрипта - 127 символов (не считая символа перехода на новую строку в конце). Всеб что выходит за его пределы, игнорируется.

Способ определения интерпретатора скрипта с помощью #! не описан в стандарте SUSv3, но доступен в большинстве реализаций UNIX.

Большинство командных оболочек и интерпретаторов в UNIX воспринимают символ # как начало комментария, поэтому при интерпретации скриптов они игнорируют начальную строку #!.

С помощью необязательных аргументов в начальной строке скрипта можно указать параметры командной строки для интерпретатора. Это бывает полезно при работе с такими интерпретаторами, как awk.

Все файловые дескрипторы, открываемые программой, которая вызывает exec, остаются открытыми на протяжении выполнения этого вызова и доступны для использования в новой программе. Часто это может быть полезно, потому что файлы, открытые вызывающей программой в определенных дескрипторах, автоматически становятся доступными для новой программы (которая при этом не должна знать их имена или открывать их заново). Командная оболочка пользуется этой возможностью для перенаправления ввода\вывода программ, которые в ней выполняются.

Встроенные команды выполняются оболочкой напрямую, без вызовов fork и exec.Консольную команду делают встроенной по одной из двух причин: повышенная эффективность или доступ к ресурсам оболочки. Например, команда cd должна изменять текущий каталог самой командной оболочки, поэтому ее нельзя выполнять в рамках отдельного процесса.

Следует взять за правило, что библиотечные функции всегда должны устанавливать флаг FD_CLOEXEC для любых открываемых ими файлов, используя описанный ниже метод.

В связи с поднимаемыми проблемами, ядро предоставляет для каждого файлового дескриптора флаг FD_CLOEXEC. Если он установлен, дескриптор автоматически закрывается после УСПЕШНОГО выполнения exec, но остается открытым, если вызов завершается неудачей.

FD_CLOEXEC на самом деле является единственным битом, который используется в флагах файлового дескриптора.

Когда для создания дубликата файлового дескриптора используются вызовы dup, dup2 или fcntl, в полученной копии флаг FD_CLOEXEC всегда сбрасывается (это поведение сложилось исторически и закреплено в SUSv3).

Во время выполнения вызова exec текст существующего процесса удаляется. Этот текст мог содержать обработчики сигналов, установленные вызывающей программой. Поскольку обработчики исчезли, ядро изменяет диспозиции для всех перехватываемых сигналов на SIG_DFL. Диспозиции всех остальных сигналов (то есть SIG_IGN и SIG_DFL) остаются без изменений. Это требование стандарта SUSv3.

Бит SA_ONSTACK тоже сбрасывается для всех сигналов в результате вызова exec.

Во время выполнения exec у процесса сохраняются сигнальная маска и сигналы, находящиеся в состоянии ожидания.

В стандарте SUSv3 рекомендуется не блокировать и не игнорировать сигналы во время выполнения сторонних программ с помощью exec. Под сторонними подразумеваются программы, написанные не нами.

Функция system позволяет вызывающей программе выполнять произвольные консольные команды. Она создает дочерний процесс для выполнения команды.

Главным недостатком функции system является ее низкая производительность.

Программы с установленным ID пользователя или группы никогда не должны применять функцию system во время работы в режиме повышенных привилегий.

Безопасные приложения, которым необходимо запускать другие программы, должны использовать для этого непосредственно вызов fork и одну из функций семейства exec: execlp иои execvp.

Во время реализации system следует обратить внимание на сигналы, генерируемые ТЕРМИНАЛОМ в результате НАБОРА специальных символьных ПОСЛЕДОВАТЕЛЬНОСТЕЙ ПРЕРЫВАНИЙ и выхода.

Команда : ничего не делеает, но всегда возвращает код успешного завершения.

Переносимые приложения должны следить за тем, чтобы функция system не вызывалась, когда диспозицией сигнала SIGCHLD является SIG_IGN, поскольку вызов waitpid в этом случае не может получить статус потомка (если игнорировать сигнал SIGCHLD явно!, статус потомка сразу же сбрасывается).

Все функции семейства exec позволяют загружать бинарные исполняемые файлы или выполнять скрипты интерпретатора. В последнем случае его интерпретатор заменяет собой текущую программу процесса.

Когда система учета ресурсов включена, ядро записывает в общесистемный файл данные о каждом процессе, который оно завершает.

Учетный файл можно анализировать с помощью стандартных инструментов (sa, lastcomm).

В силу исторических причин учет ресурсов изначально применяли для взимания платы с пользователей за работу в многопользовательских UNIX-системах.

Система учета ресурсов не учитывается в стандарте SUSv3, хотя и доступна в большинстве равновидностей Linux.

Для включения и отключения учета ресурсов привилегированный процесс должен воспользоваться системным вызовом acct.

После включения учета ресурсов данные, записанные в структуру acct, сбрасываются в файл при завершении каждого процесса.

Начиная с версии 2.6.8, ядро Linux поддерживает альтернативную версию учетного файла (известную как версия 3), лишенную ограничений традиционной версии.

В Линукс!! доступен уникальны для этой системы вызов clone, предназначеный для создания новых процессов. От fork и vfork он отличается тем, что позволяет 

Когда система учета ресурсов включена, ядро записывает в общесистемный файл данные о каждом процессе, который оно завершает.

Учетный файл можно анализировать с помощью стандартных инструментов (sa, lastcomm).

В силу исторических причин учет ресурсов изначально применяли для взимания платы с пользователей за работу в многопользовательских UNIX-системах.

Система учета ресурсов не учитывается в стандарте SUSv3, хотя и доступна в большинстве равновидностей Linux.

Для включения и отключения учета ресурсов привилегированный процесс должен воспользоваться системным вызовом acct.

После включения учета ресурсов данные, записанные в структуру acct, сбрасываются в файл при завершении каждого процесса.

Начиная с версии 2.6.8, ядро Linux поддерживает альтернативную версию учетного файла (известную как версия 3), лишенную ограничений традиционной версии.

В Линукс!! доступен уникальны для этой системы вызов clone, предназначеный для создания новых процессов. От fork и vfork он отличается тем, что позволяет более точно контролировать этапы создания процесса. Его в основном применяют в библиотеках, отвечающих за работу с потомками выполнения.

Отличие от fork состоит в том, что клонированный потомок не продолжит работу с момента вызова, а сначала вызывает функцию, указанную в аргументе func; мы будем называть ее дочерней функцией.

Клонированный дочерний процесс завершается либо при возврате функции func (в этом случае возвращаемое значение становиться кодом завершения процесса), либо при вызове exit (или _exit).

Клонированный потомок либо получает копию памяти вызывающего процесса, либо разделяет ее с ним.

Поскольку клонированный потомок может разделять память с родителем (как в случае с vfork), он не может использовать родительский стек.

В отличии от fork и vfork, clone позволяет выбрать сигнал завершения процесса, который будет отправлен родителю по завершении процесса.

Оставшиеся аргументы clone - ptid, tls и ctid относятся к реализации потока выполнения - в частности, к использованию его идентификатора и локального хранилища. (в версиях Линукс до 2.4 включительно эти три аргумента отсутствуют в вызове clone; их специально добавили в Linux 2.6 для поддержки библиотеки потоков POSIX NPTL).

На данном этапе стоит отметить, что наши попытки провести грань между терминами "процесс" и "поток" в некоторой степени являются жонглированием словами. Это немного помогает при знакомстве с понятием единицы планирования ядра (Kernel Scheduling Entity, KSE); с его помощью в технической литературе иногда описывают объекты, с которыми работает планировщик ядра. На самом деле потоки и процессы являются лишь экземплярами KSE, поддерживающими разную степень совместного использования атрибутов (виртуальной памяти, дескрипторов открытых файлов, действий сигналов, идентификатора процесса и т.д).

Спецификация POSIX потоков описывает лишь один из множества возможных способов разделения атрибутов между потоками.

Две главные реализации POSIX потоков, доступные в Linux: LinuxThreads (old), NTPL (new).

Если указать флаг CLONE_FILES, родитель и потомок будут применять общую таблицу дескрипторов. Спецификация POSIX-потоков требует, чтобы все потоки в процессе пользовались общими дескрипторами открытых файлов.

Если указать флаг CLOSE_FS, родитель и потомок будут использовать общую информацию, связанную с ФС. Разделение атрибутов ФС, предоставляемое этим флагом, является обязательным условием для POSIX потоков.

CLONE_SIGHAND: родитель и потомок будут использовать общую таблицу действий сигналов. ОН не затрагивает маску сигнала и набор ожидающих сигналов - эти данные всегда уникальны для каждого процесса. Разделение действий сигналов является обязательным условием для POSIX потоков.

CLONE_VM: родитель и потомок будут использовать общие страницы виртуальной памяти (vfork). Иначе, потомок получает копию виртуальной памяти родителя (fork). Разделение вирт памяти является одной из основополагающих характеристик потоков в целом и обязательным требованием POSIX потоков в частности.

CLONE_THREAD: потомок будет помещен в одну группу потоков с родителем. В противном случае потомо помещается в новую группу, выделенную специально для него. Группы потоков выполнения (Linux 2.4) были добавлены, чтобы программные библиотеки могли выполнять требования POSIX, согласно которому все потоки в процессе должны иметь единый идентификатор PID. Группа потоков представляет собой группу  экземпляров KSE, которые разделяют идентификатор группы токов (TGID).

Начиная с Линукс 2.4, вызов getpid возвращает идентификатор TGID вызывающего потока. Иными словами, TGID ничем не отличается от идентификатора процесса (PID).

Каждый поток имеет уникальный идентификатор (TID) в рамках своей группы (gettid).

TID является уникальным в рамках всей системы; ядро гарантирует, что любой такой идентифакатор никогда не совпадет с идентификатором любого процесса в системе, за исключением тех случаев, когда потоков в группе является лидирующим для процесса. Первый поток в группе имеет тот же идентификатор, что и сама группа. Такой поток называют лидирующим.

Все потоки в группе имеют один и тот же идентификатор родительского процесса - тот, что принадлежит лидеру группы.

Родительский процесс получает сигнал SIGCHLD (или сигнал завершения) только после того, как завершатся все потоки в группе. Такое поведение соответствует требованиям, предъявляемым к POSIX потокам.

Когда поток с флагом CLONE_THREAD завершает работу, поток, который создал его с помощью вызова clone, не получает никакого сигнала. Соответственно, вызовы wait не подходят для ожидания потоков, созданных таким образом. Это отвечает требованиям стандарта POSIX. POSIX-поток не тождественнен процессу; его нельзя отследить с помощью wait. Вместо этого его следует присоединить.Для определения того, что поток, созданный с использованием флага CLONE_THREAD, завершил работу, применяется специальное средство синхронизации - фьютекс.

Если какой либо поток выполнит exec, все потоки в группе, кроме лидера, щавершатся (это поведение соответствует требованиям стандарта POSIX), а новая программа будет выполнена в потоке-лидере.

Последние три аргумента сис выз close относятся к реализации потока выполнения.

Флаги CLONE_PARENT_SETTID, CLONE_CHILD_SETTID и CLONE_CHILD_CLEARTID были добавлены в Linux 2.6 для поддержки реализации POSIX потоков. Первый и третий флаги также используются в реализации NPTL потоков.

Первый флаг нужен для того, чтобы поточная библиотека имела надежный способ получения идентификатора нового потока.

Аргумент ctid представляет собой механизм, с помощью которого библиотека NPTL получает уведомлние о завершении потока. Это уведомление необходимо для функции pthread_join.

Если указать флаг CLONE_SETTLS, аргумент tls будет указывать на структуру user_decs, описывающую буфер локального хранилища, которое будет использоваться в этом потоке. Этот флаг был добавлен в Linux 2.6 для поддержки локальных хранилищ на уровне потока в библиотеке NPTL.

Начиная с версии 2.4.19, ядро Linux поддерживает отдельные пространства имен файловой системы для каждого процесса, которые представляют собой набор точек подключения (CLONE_NEWNS).

Родительским является процесс, которому приходит сигнал при завершении потомка.

Если указать флаг CLONE_PTRACE, потомок трассируемого процесса тоже будет трасироваться.

Если указать флаг CLONE_VFORK, выполнение родителя приостанавливается до тех пор, пока потомок не освободит ресурсы своей виртуальной памяти с помощью вызовов exec или _exit (как в случае с vfork).

Для ожидания потомков, созданных с помощью вызова clone, в аргумент options вызовов waitpid, wait3 или wait4 (который является битовой маской) можно передавать следующие значения (актуальные только для Линукс): __WCLONE, __WALL, __WNOTHREAD.

Разница между результатами замера производительности clone и vfork связано с тем, что последним осуществляется копирование данных в дочерний процесс.

Процесс обладает множеством атрибутов.

Когда включен учет ресурсов, ядро записывает в файл учетные сведения о каждом завершающемся процессе в системе.

POSIX-потоки - Pthreads

По аналогии с процессами потоки выполнения представляют собой механизм для одновременного выполнения нескольких параллельных задач в рамках одного приложения.

Традиционный для UNIX процесс является всего лишь частным случаем многопоточного процесса; он состоит из одного потока)

В многопроцессорных системах возможно реально параллельное выполнение потоков.

В некоторых ситуациях потоки имеют преимущество перед процессами.
1) обмен информации между процессами имеет свои сложности
2) создание процесса с помощью fork потребляет относительно много ресурсов
потоки помогают избавиться от этих проблем
В Linux потоки реализованы с помощью системного вызова clone; отличия в скорости между ним и вызовом fork показаны в табл. 28.3.

Помимо глобальной памяти, потоки также разделяют целый ряд других атрибутов (это когда атрибуты являются глобальными для всего процесса, а не для отдельных потоков).

Потоки, имея подходящие указатели, могут обмениваться данными через стеки друг друга.

1980-1990 существование нескольких разных программных интерфейсов для работы с потоками.
1995 - в POSIX.1 был описан API-интерфейс POSIX-потоков, который позже вошел в состав SUSv3.

pthread_t - тип данных в Pthreads (POSIX-потоках), который определяет идентификатор потока.

Стандарт не содержит подробностей о том, как именно должны быть представлены типы данных Pthreads. Это означает, что программа не должна зависеть от структуры или содержимого переменных любого из этих типов.

В традиционном программной интерфейсе UNIX переменная errno является глобальной и целочисленной. Однако этого недостаточно для многопоточ. программ. В многопоточ. программах каждый поток имеет свой отдельный экземпляр errno. В Linux (и в большинстве других реализ. UNIX) для этого используется примерно один подход: errno объявляется в виде макроса, который разворачивается в вызов функции, возвращающий изменяемое значение вида lvalue, уникальное для каждого потока.

Функции в программном интерфейсе Pthreads ведут себя иначе в отношении возвращаемых значений, если сравнить их с традиционными сис. вызовами и некоторыми функциями. В случае успеха возвращается 0, но при ошибке используется положительное значение. Это одно из тех значений, которые можно присвоить переменной errno в традиционных системных вызовах UNIX.

В Linux программы, которые используют программных интерфейс Pthreads, должны компилироваться с параметром cc -pthread.

Сразу после запуска программы итоговый процесс состоит из одного потока, который называют исходным или главным.

Аргумент thread в pthread_create указывает на буфер типа pthread_t, в который перед возвращением функции pthread_create записывается уникальный идентификатор созданного потока.

Выполнение потока прекращается по одной из следующих причин:
1) начальная функция выполняет инструкцию return
2) поток вызывает функцию pthread_exit
3) поток отменяется с помощью функции pthread_cancel
4) любой из потоков вызывает exit или главный поток выполняет иснтрукцию return (внутри main), что приводит к немедленному завершению всех потоков в процессе.

Функция pthread_exit завершает вызывающий поток и указывает возвращаемое значение, которое может быть получено из другого потока с помощью функции pthread_join. Вызов этой функции эквивалентен выполнению инструкции return внутри начальной функции потока, за исключением того, что pthread_exit можно вызвать из любого кода, запущенного начальной функцией. Если главный поток вызовет эту функцию вместо exit или инструкции return, остальные потоки продолжат выполнение.

С помощью функции pthread_self поток может получить собственный идентификатор.

Функция pthread_equal позволяет проверить на тождественность два идентификатора потоков. Необходимость в ней возникает изза того, что тип данных pthread_t должен восприниматься как непрозрачный.

В Линукс идентификаторы потоков являются уникальными для ВСЕХ процессов. Однако в других системах это может быть не так.

Идентификаторы POSIX и обычных потоков, возвращаемые сис. выз. gettid (доступным только в Linux) - это не одно и тоже. Идентификатор POSIX потока присваивается и обслуживается реализацией поточной библиотеки.

Функция pthread_join ждет завершения потока, обозначенного аргументом thread (если поток уже завершился, она сразу возвращается). Эта операция называется присоединением.

Если поток не отсоединен, мы должны присоединиться к нему с помощью pthread_join. Если нам не удастся это сделать, завершенный поток превратиться в аналог процесса-зомби.

Вызов функции pthread_join() для идентификатора уже присоединенного потока может привести к непредсказуемым последствиям; например, мы можем присоединиться к потоку, который был создан позже и повторно использует тот же идентификатор.

Процедура, которую выполняет функция pthread_join для потоков, похожа на действие вызова waitpid в контексте процессов. Но между ними есть и заметные различия.
1) Потоки не имеют иерархии
2) Невозможно присоединиться к любому потоку

Операция "присоединение к произвольному потоку" несовместима с модульной архитектурой приложения.

По умолчанию потоки являются присоединяемыми; это означает, что после завершения их статус можно получиьть из другого потока с помощью функции pthread_join. Иногда статус, возвращаемый потоком, не имеет значения; нам просто нужно, чтобы система автоматически освободила ресурсы и удалила поток, когда тот заверишится. В этом случае мы можем пометить поток как отсоединенный, воспользовавшись функцией pthread_detach.

Если поток уже был отсоединен, мы больше не можем получить его возвращаемый статус с помощью функции pthread_join. Мы также не можем снова сделать его присоединяемым.

Отсоединенный поток не становиться устойчивым к вызову exit, сделанному в другом потоке, или к инструкции return, выполненной в главной программе.

Работа с сигналами в многопоточной приложении требует тщательного проектирования (как правило, рекомендуется избегать использования сигналов в многопоточных программах).

Ключевой особенностью потоков является более простой обмен информацией по сравнению с процессами.

Мьютексы позволяют потокам синхронизировать использование общих ресурсов. Условные переменные дополняют это решение, позволяя потока оповещать друг друга о том, что разделяемая переменная (или другой общий ресурс) изменила свое состояние.

Термин "критический участок" относится к участку кода, который работает с общими ресурсами и чье выполнение должно быть атомарным. То есть выполнение не должно быть прервано другим потоком, который в этот самый момент получает доступ к тому же ресурсу.

Такое непредсказуемое поведение программы из листинга 30.1 является результатом причудливой работы планировщика ядра. В сложных программах подобные ошибки возникают редко и их бывает сложно воспроизвести - а значит, сложно найти. На первый взгляд может показаться, что проблема легко решается путем замены трех инструкций threadFunc внутри цикла for одним-единственным выражением: glob++. Однако во многих программных архитектурах (таким как RISC) компилятору все равно бы пришлось преобразовать это выражение в команды машинного кода, которые являются эквивалентом трех инструкций из цикла в функции threadFunc. Иными словами, несмотря на внешнюю простоту, даже простая операция инкремента может оказаться неатомарной и демонстрировать поведение, описанное выше.

В любой момент времени максимум один мьютекс может удерживать мьютекс закрытым. Когда поток закрывает мьютекс, он становится его владельцем. Только владелец мьютекса может его открыть.

Прежде чем вы сможете использовать мьютекс, он должен быть инициализирован. В случае с статически выделенным мьютексом это можно сделать путем присваивания ему значения PTHREAD_MUTEX_INITIALIZER.

После инициализации мьютекс находится в открытом состоянии.

Если во время блокирования мьютекса обнаруживается, что он уже закрыт, тогда вызывающий поток блокируется ожидая освобождения мьютекса.

Если вызывающий поток сам закрыл уже закрытый ИМ мьютекс, тогда, если это стандартных тип мьютекса, тогда случится одно из двух, в зависимости от реализации: либо поток войдет в состояние взаимного блокирования, пытаясь закрыть мьютекс, которым он уже владеет, либо вызов завершится неудачей и вернет ошибку EDEADLK.

Функция pthread_mutex_trylock делает тоже самое, что и pthread_mutex_lock, но если мьютекс закрыт, возвращает ошибку EBUSY.

Поток, который периодически вызывает функцию pthread_mutex_trylock, чтобы проверить, можно ли закрыть мьютекс, рискует стать наименее "удачливым" с точки зрения частоты получения доступа к ресурсу по сравнению с потоками, которые находятся в очереди и закрывают мьютекс с помощью функции pthread_mutex_lock.

Мьютексы реализованы с помощью атомарных операций на машинном языке (выполняемых на участках памяти, видимых для всех потоков) и требуют выполнения системного вызова только в случае, если за установление блокировки конкурируют сразу несколько потоков.

В Linux мьютексы реализованы с применением фьютексов, а конфликты при блокировании разрешаются с помощью системного вызова futex.

Если один и тот же набор мьютексов закрывается несколькими потоками, может произойти взаимное блокирование.

Самый простой способ избежать подобного взаимного блокирования заключается в определении иерархии мьютексов. Если потоки могут закрыть один и тот же набор мьютексов, они всегда должны делать это в одном и том же порядке. Существует и друга, менее популярная стратегия, которую вкратце можно описать как "попробуй, а затем отойди".

Статическое значение PTHREAD_MUTEX_INITIALIZER можно использовать только для инициализации мьютексов, статически выделенных атрибутами по умолчанию. Во всех других случаях следует применять динамическую инициализацию с помощью функции pthread_mutex_init.

В стандарте SUSv3 сказано, что инициализация уже инициализированного мьютекса приводит к непредсказуемым последствиям; этого не следует делать.

Когда мьютекс, выделенный автоматически или динамически, больше не нужен, его следует уничтожить с помощью функции pthread_mutex_destroy (для мьютексов, инициализированных статически с использовании PTHREAD_MUTEX_INITIALIZER, ее можно не вызывать).

Безопасное уничтожение мьютекса возможно, только когда он находится в открытом состоянии и нет ни одного потока, который бы впоследствии планировал его закрыть.

Мьютекс, уничтоженный с помощью функции pthread_mutex_destroy, в дальнейшем можно будет повторно инициализировать, используя функцию pthread_mutex_init.

В Linux поведение мьютексов PTHREAD_MUTEX_DEFAULT и PTHREAD_MUTEX_NORMAL является идентичным.

Мьютекс предотвращает одновременный доступ к переменной из разных потоков. Условные переменные позволяют потокам информировать друг друга об изменениях в состоянии разделяемых переменных (или других общих ресурсов) и ждать (блокируясь) получения таких уведомлений.

Как и в случае с мьютексом, перед использованием условной переменной ее необходимо инициализировать. В случае со статически выделяемыми ус пер это делается путем присваивания им значения PTHREAD_COND_INITIALIZER.

Основными операциями с условными переменными являются оповещение и ожидание.

Операция ожидания позволяет блокировать поток до тех пор, пока не будет получено оповещение.

Условная переменная не содержит никакой информации о состоянии. Это всего лишь механизм обмена данными о состоянии приложения. Если в момент создания уведомления условную переменную не ожидает ни один поток, это уведомление теряется. Если позже какой то поток начнет ждать условную переменную, он будет разблокирован только после создания нового уведомления.

У условной переменной всегда есть связанный с ней мьютекс.

У каждой условной переменной есть свой предикат на основе одной или нескольких разделяемых переменных.

Вызов pthread_cond_wait должет выполняться циклом while, а не инструкцией if. Дело в том, что при возврате из функции pthread_cond_wait состояние предиката может быть произвольным (ПРЕДПОЛОЖЕНИЕ, не гарантия).

В некоторых реализациях поток, ожидающий условную переменную, может возобновить работу, даже если никакой другой поток не передал этой переменной уведомление. Такие ложные срабатывания являются (редким) последствием применения методик, необходимых для эффективной реализации многопоточности на некоторых многопроцессорных системах, и специальной допускаются стандартом SUSv3.

Стандарт SUSv3 гласит, что повторная инициализация условной переменной приводит к непредсказуемому поведению; этого не следует делать!!

Уничтожение условной переменной является безопасным только в том случае, если ее не ожидает ни один из потоков. Условную переменную, уничтоженную с помощью функции pthread_cond_destroy в дальнейшем можно будет повторно инициализировать, используя функция pthread_cond_init.

Функция считается потокобезопасной, если она может быть безопасно вызвана сразу из двух потоков.

Типичный признак того, что функция не является потокобезопасной: она использует глобальные или статические переменные, которые разделяются всеми потоками.

Сделать функцию потокобезопасной можно, например, привязав к ней мьютекс. С другой стороны, это означает, что в любой момент времени функцию может выполнять только один поток - в этом случае говорят, что доступ к функции сериализованный.

Более сложным решением является связывание мьютекса с разделяемый переменной. После этого нужно определить, какие участки функции являются критическими, и затем закрывать\открывать мьютекс только при их выполнении.

Для облегчения разработки приложений все функции стандарта SUSv3 (кроме тех, что в таблице 31.1) должны быть реализованы потокобезопасными. Вышеупомянутые стандарты не запрещают делать функции из таблицы 31.1 потокобезопасными. Но для переносимости на это полагаться не стоит.

Единовременная инициализация реализована в виде функции pthread_once.

Использование критических участков для реализации потоковой безопасности является значительным прорывом по сравнению с назначением каждой функции отдельного мьютекса. Однако этот подход все равно не очень эффективен, поскольку на закрытие и открытие мьютексов тоже тратятся ресурсы. Реентерабельные (или повторно входимые) функции позволяют достичь потоковой безопасности без применения мьютексов. Это делается за счет отказа от глобальных и статических переменных.

Не все функции можно сделать реентерабельными. Обычно это объясняется следующими причинами.
1) некоторые функции ввиду своего назначения должны получать доступ кк глобальным структурам данных (malloc) - реализованы с помощью мьютексов.
2) некоторые функции (созданные до изобретения потоков) имеют интерфейс, который делает их нереентерабельными по определению.

Самый эффективный способ обеспечения потоковой безопасности функции - это сделать ее реентерабельной. Так должны быть реализованы все новые библиотечные функции.

Задействование данных, относящихся к отдельному потоку, позволяет сделать функцию потокобезопасной, не изменяя при этом ее интерфейс. Функции, использующие такие данные, могут работать чуть медленнее реентерабельных, но позволяют оставлять ранее написанный код без изменений. Этот способ позволяет функции иметь отдельную копию переменной для каждого потока, который ее вызывает.

ДУП предоставляют функции хранилище, относящееся к отдельному потоку.

ДУП являются постоянными; они продолжают существовать между вызовами. Благодаря этому функция в случае необходимости может передавать каждому вызывающему потоку отдельный итоговый буфер.

Вызов pthread_key_create приводит к созданию нового ключа, связанного с данными уровня потока.

Поскольку возвращенный ключ используется во всех потоках процесса, аргумент key должен указывать на глобальную переменную.

При завершении потока, значение key которого не равно NULL, программный интерфейс Pthreads автоматически вызывает функцию-деструктор, передавая ей это значение в качестве аргумента. key обычно является указателем на блок данных уровня потока для этого ключа.

Если деструктор не требуется, аргументу destructor можно присвоить NULL.

Если поток содержит несколько локальных блоков данных, деструкторы для кжадого из них вызываются в произвольном порядке. Следовательно, функции деструкторы должны уметь действовать независимо друг от друга.

Функция pthread_setspecific делает запрос к программному интерфейсу Pthread чтобы тот сохранил копию value в структуре данных, которая связывает ее с вызывающим потоком и ключом key. Функция pthread_getspecific выполняет обратную операцию, возвращая значение, которое ранее было связано с заданным ключом этого потока.

Программный интерфейс Pthreads предоставляет массив указателей на блоки данных каждого отдельного потока.

При создании потока указатели на все его данные инициализируются значением NULL. Это означает, что, когда поток впервые вызывает нашу функцию, он должен сначала сделать вызов pthread_getspecific, чтобы проверить, имеет ли он значение, связанное с ключом. Если такого значения нет, функция выделяет блок памяти и сохраняет указатель на него с помощью вызова pthread_setspecific.

Ключ используется для того, что бы можно было отличить элементы данных уровня потока, задействуемые разными функциями.

Стандарт SUSv3 требует, чтобы программа поддерживала как минимум 128 ключей (_POSIX_THREAD_KEYS_MAX).

TLS используется для данных, которые должны сохраняться на протяжении всего времени жизни потока, но при этом быть уникальными для каждого потока.

По аналогии с данными уровня потока локальное хранилище потока предоставляет средство постоянного хранения информации. Это нестандартная концепция.

Потоковую безопасность можно обеспечить за счет реентерабельных функций.

Иногда возникает необходимость в отмене потока; это выглядит как передача потоку запроса с просьбой немедленно закончить работу.

Функция pthread_cancel отправлят заданному потоку запрос отмены. Эта функция лишь выполняет запрос. Она не ждес завершения заданного потока.

Функции pthread_setcancelstate и pthread_setcanceltype устанавливают флаги, которые позволяют управлять реакцией потока на запрос отмены.

При вызове fork потомок наследует тип и состояние отмены вызывающего потока. При вызове exec тип и состояние отмены главного потока новой программы сбрасываются к значения соответственно PTHREAD_CANCEL_ENABLE и PTHREAD_CANCEL_DEFERRED.

Если возможность отмены включена и отложена, запрос выполняется, тогда поток достигает следующей точки отмены, то есть вызова одной из функций, определенных системой.

Во время присоединения отмененного потока значение, возвращенное во втором аргументе функции pthread_join, равно PTHREAD_CANCELLED.

Единственное назначение функции pthread_testcancel - быть точкой отмены.

Поток может установить один или несколько обработчиков для освобождения ресурсов - это функции, которые автоматически вызываются при отмене потока (pthrad_cleanup_push, pthread_cleanup_pop).

Каждый поток может иметь стек обработчиков для очистки ресурсов. При отмене потока эти обработчики выполняются снизу вверх.

В качестве дополнительного удобства все обработчики для очистки ресурсов, которые не сработали, выполняются автоматически, если поток завершается с помощью pthread_exit (это не касается ситуаций, когда для завершения используется инструкция return).

Если сделать поток асинхронно отменяемым, его можно будет отменить в любой момент; эта процедура не задерживается до достижения потоком следующей точки отмены. Проблема с асинхронной отменой заключается в том, что, хотя обработчики очистки ресурсов по прежнему запускаются, они не могут определить состояние потока.

В целом, асинхронно отменяемые потоки не могут выделять никаких ресурсов или владеть мьютексами, семафорами или блокировками. Иными словами, существует несколько случаев, когда асинхронная отмена может оказаться полезной.

Реализации POSIX потоков в Linux: LinuxThreads и NPTL.

Главному потоку под стек выделяется намного больше места, чем остальным.

С помощью функции pthread_attr_setstacksize можно установить атрибут потока, определяющий размер стека. Связанная с ней функция pthread_attr_setstack позволяет управлять как размером, так и местоположением стека, хотя последнее может негативно сказаться на переносимости приложения.

Минимальный размер стека, доступный в текущей системе, можно узнать с помощью вызова sysconf(_SC_THREAD_STACK_MIN).

Между сигналами и потоками возникают заметные конфликты. В основе этих конфликтов, как правило, лежит необходимость сохранения традиционной для однопоточных процессов семантики в сочетании с разработкой такой модели сигналов, которая была бы уместной в условиях многопоточности.

Чтобы понять, как UNIX сигналы соотносятся с моделью Pthreads, необходимо понимать, какие из аспектов сигнальной модели распространяются на весь процесс, а какие относятся к отдельным потокам.
1) Назначение сигналов распространяется на весь процесс.
2) Действия сигналов распространяются на весь процесс.
3) Сигнал может быть направлен как процессу в целом, так и отдельному потоку.
4) Когда сигнал доставляется многопоточному процессу, у которого есть подходящий обработчик, ядро наугад выбирает один поток, чтобы доставить ему этот сигнал и дать возможность его обработать.
5) Маска сигнала относится к каждому отдельному потоку (понятия глобальной маски, распространяемой на все потоки в многопоточной среде, не существует).
6) Ядро ведет учет сигналов, которые ожидают доставки как в процесс целиком , так и в каждый отдельный его поток.
7) Если вызов pthread_mutex_lock прерывается обработчиком сигнала, он всегда автоматически перезапускается.
8) Альтернативный стек сигналов относится к каждому отдельному потоку.

Новый поток наследует от своего создателя копию сигнальной маски. Изменить и\или извлечь эту маску он может с помозью вызова pthread_sigmask.

Функция pthread_kill отправляет сигнал другому потоку в ТОМ ЖЕ процессе. Поскольку идентификатор потока (pthread_t) уникален только в рамках ОДНОГО ПРОЦЕССА! мы не можем использовать функцию pthread_kill для отправки сигнала потоку из другого процесса.

Ни одну функцию из состава Pthreads нельзя безопасно вызвать внутри обработчика сигнала.

Когда любой поток делает вызов одной из функций семейства exec, происходит полная замена вызывающей программы.

Когда многопоточная программа делает вызов fork, в дочерний процесс копируется только вызывающий поток (его идентификатор в новом процессе (pthread_t) будет таким же, как у потока родителя, вызвавшего fork()). Остальные потоки дочернего процесса исчезают; деструкторы данных уровня потока и обработчики для очистки ресурсов, принадлежащие им, игнорируются.

В многопоточной программе fork может привести к утечкам памяти в дочернем процессе. Ввиду этого вызов fork в многопоточных программах обычно рекомендуется использовать только в том случае, если после него сразу же следует вызов exec.

Благодаря exec все объекты Pthreads в дочернем процессе исчезают, поскольку новая программа перезаписывает его память.

На случай, когда приложение должно выполнить какие то действия между вызовами fork и exec, программный интерфейс Pthreads предоставляет механизм для объявления обработчиков создания нового процесса. Эти обработчики устанавливаются с помощью вызова pthread_atfork (обработчики создания нового процесса).

Потомок, созданный вызовом fork, наследует обработчики создания нового процесса от вызывающего потока.

Если какой либо поток вызовет exit или главная программа выполнит инструкцию return (что то же самое), все потоки будут сразу же уничтожены.

Разница между моделями реализации потоков заключается в способе привязки потоков к единицам планирования ядра, которые используются системой для выделения процессорного времени и других ресурсов (в традиционных реализациях UNIX, которые разрабатывались задолго до появления потоков, термин "единица планирования ядра" является синонимом процесса).

Linux предоставляет две основные реализации программного интерфейса Pthreads: LinuxThreads, NPTL (Native POSIX Thread Library).

Библиотека LinuxThreads уже считается устаревшей; она не поддерживается в glibc версии 2.4 и выше. Все нововведения, касающиеся потоков, добавляются в библиотеку NPTL.

Начиная с glibc 2.3, вызов _exit, а значит, и библиотечная функция exit превратились в обертку вокруг exit_group, в то время как функция pthread_exit на самом деле выполняет в ядре системный вызов _exit, что приводит к завершению только вызывающего потока.

С появлением многопоточности разница между exit и _exit стала более существенной. Первый все также выполняет все действия очистки и т.д, а второй - кроме того, что он также продолжает ничего не очищать еще и стал завершать ТОЛЬКО вызывающий поток. _exit завершает поток на уровне ядра.

Для удовлетворения требований NPTL был переписан планировщик ядра для эффективного планирования большого количества (то есть тысяч) экземпляров KSE.

Внутри библиотеки NPTL используются первые два сигнала реального времени, недоступные обычным приложениям.

Среди продвинутых возможностей программного интерфейса Pthreads можно выделить следующие:
1) планирование в режиме реального времени.
2) разделяемые мьютексы и условные переменные процесса.
3) дополнительные средства синхронизации потоков (барьеры, блокировки для чтения\записи и циклические блокировки).

Потоки плохо сочетаются с асинхронными сигналами; при проектировании многопоточных приложеный использования сигналов следует избегать любыми путями.

Наиболее распространенными реализациями многопоточности в Linux явлюятся библиотеки LinuxThreads и NPTL.

Группы процессов и сессии составляют двухуровневые иерархические отношения между процессами: первые являются наборами связанных между собой процессов, а вторые - групп.

Группы процессов и сессии - это абстракции, созданные для поддержки управления заданиями в командной оболочке; это позволяет выполнять команды как в интерактивном, так и в фоновом режиме. Понятие "задание" часто используется в качестве синонима группы процессов. Группы процессов, сессии и управление заданиями будут рассмотрены в этой главе. Понятие задания часто используется в качестве синонима группы процессов.

Группа процессов - процессы, разделяющие один и тот же PGID.

В каждой группе есть процесс лидер - процесс, который создал эту группу.

Группа процессом имеет жизненный цикл.

Процесс может покинуть группу либо завершившись, либо перейдя в другую группу.

Сессия - это набор групп процессов.

Членство процесса в сессии определяется идентификатором SID.

Все процессы в сессии разделяют один и тот же контролирующий терминал, который устанавливается при первом открытии устройства терминала лидером сессии. Любой контролирующий терминал может быть связан не более чем с одной сессией.

В любой момент времени одна из групп процессов в сессии является активной, а остальные - фоновыми.

Сигнал, сгенерированный пользователем в терминале с помощью комбинации клавиш, передается все участникам активной группы процессов.

В Linux идентификаторы PGID\SID любого процесса можно определить с помощью файлов вида /proc/PID/stat.

Основное назначение групп процессов и сессий связано с управлением заданиями в командной оболочке.

Когда пользователь входит в систему в интерактивном режиме, он задействует контролирующий терминал. Командная оболочка, задействованная при этом, становиться лидером сессии, контролирующим процессом для терминала, а также единственным участником своей собственной группы процессов. Любые команды или конвейеры команд, запущенных из этой оболочки, становятся новыми процессами и помещаются в новую группу.

& создает фоновую группу процессов (без него - активную).

Группы процессов иногда можно применять не только для управления заданиями. Они имеют два полезных свойства: родительский процесс может ожидать любого из своих потомков в определенной группе, и сигнал может быть отправлен сразу всем участникам группы.

Для получения текущего идентификатора группы процессов используется вызов getpgrp.

Системный вызов setpgid позволяет сменить группу процесса с идентификатором pid на значение, указанное в аргументе pgid.

Задание - команда или конвейер.

Системный вызов getsid возвращает идентификатор SID процесса, указанного с помощью аргумента pid.

Если вызывающий процесс не является лидером своей группы, вызов setsid создает новую сессию (вызывающий процесс не имеет контролирующего терминала. Любое соединение с контролирующим терминалом, установленное ранее, разрывается).

Все члены группы процессов должны быть частью одной и той же сессии.

Контролирующий терминал наследуется потомком, созданным с помощью fork, и сохраняется на протяжении работы вызова exec.

Если впоследствии произойдет отключение терминала, ядро уведомит об этом контролирующий процесс, отправив ему сигнал SIGHUP.

Если процесс имеет контролирующий терминал, он может получить его файловый дескриптор, открыв специальный файл /dev/tty.

Функция ctermid возвращает путь к контролирующему терминалу.

В любой момент времени только одна группа процессов в рамках сессии может быть активной. Только активная группа процессов может свобоно выполнять чтение и запись данных в контролирующем терминале. Сигнал, который генерируется в результате нажатия подходящей комбинации клавиш, передается драйвером терминала участникам активной группы процессов.

Функции tcgetpgrp и tcsetpgrp используются соответственно для получения и изменения группы процессов терминала. Они в основном применяются командными оболочками для управления заданиями.

Эти функции являются частью стандарта SUSv3.

По умолчанию сигнал SIGHUP завершает процесс терминала.

В качестве контролирующего процесса обычно выступает командная оболочка.

Командная оболочка, получив сигнал SIGHUP, передает его всем заданиям, которые она создала (если установлен такой обработчик).

Если сигнал SIGHUP, передающийся контролирующему процессу в результате отключения терминала, приводит к завершению этого процесса, он отправляется все участникам активной группы. Это является следствием завершения контролирующего процесса и не связано непосредственно с сигналом SIGHUP.

Встроенная команда exec заставляет командную оболочку выполнить вызов exec и заменить себя заданной программой.

Возможность управления заданиями впервые появилась в командной оболочке csh в системе BSD; это случилось в 1980 году. Она позволяет пользователю командной строки выполнять несколько программ (заданий): одну в активном режиме, а все остальные - в фоновом. Задания можно останавливать, возобновлять и переключать между фоновым и активным режимами.

Если после команды указать знак амперсанда, она будет запущена в качестве фонового задания.

Каждому заданию, помещенному в фон, командная оболочка присваивает уникальный номер.

Команды позволяют обращаться к заданиям в формате %num, где num - это номер, назначенный заданию командной оболочкой.

Встроенная команда jobs выводит список всех фоновых заданий.

Только активные процессы могут считывать ввод из контролирующего терминала и получать сгенерированные им сигналы.

Фоновое задание делается активным с помощью функции fg.

Bg используется для возобновления задания в фоновом режиме после остановки.

Когда фоновое задание в какой то момент завершается, оболочка, прежде чем отобразить следующее приглашение командной строки, выводит сообщение.

Только процесс из активного задания может считывать данные из контролирующего терминала.

Фоновым заданиям по умолчанию разрешено напрявлять вывод в контролирующий терминал.

Как видите, командная оболочка по прежнему является активной группой процессов по отношению к терминалу.

Поскольку в большинстве приложений процедура управления заданиями является прозрачной, для работы с сигналами, которые с ней связаны, не нужно предпринимать дополнительных действий. Исключение состовляют программы, которые работают с экраном, - например, vi и less.

Стоит отметить, что обработчик SIGTSTP может прервать работу некоторых блокирующих системных вызовов.

Приложения должны обрабатывать сигналы, сгенерированные терминалом или предназначенные для управления заданиями, только если они не были проигнорированы ранее.

Сигнал SIGHUP игнорируется, если программа выполняется посредством утилиты nohup(1).

После завершения родителя дочерний процессне просто становится сиротой, но и входит в осиротевшую группу. Согласно стандарту SUSv3 группа процесов считается осиротевшей, если родитель каждого ее участника либо сам входит в эту группу, либо не является членом ее сессии.

Лидер сессии по определению находится в осиротевшей группе процессов. Это вытекает из того факта, что вызов setsid создает новую группу в новой сессии, отличной от той, в которой размещен родитель лидера.

Группа процессов считается сиротой, если ни один из ее участников не имеет родителя в другой группе в рамках той же сессии.

В Linux, как и в большинстве других реализациях UNIX, для распределения ресурсов процессора по умолчанию применяется циклическое разделение времени.

Существует атрибут, значение nice, который позволяет процессу опосредственно влиять на алгоритм планирования ядра (по умолчанию равен 0). Непривилегированные процессы могут только понижать свой приоритет, делая значение nice больше нуля. Делая это, они ведут себя "хорошо" (nice) по отношению к другим процессам, от чего и происходит название данного атрибута.

Значение nice наследуется потомком, созданным с помощью fork, и сохраняется на протяжении работы вызова exec.

Значение nice не устанавливает четкой иерархии планирования процессов; вместо этого она играет роль весового коэфициента, на основе которого планировщик ядра выдает повышенные приоритеты.

Степень влияния значения nice на планирование процессов зависит от версии ядра Linux или от конкретной UNIX системы.

Системные вызовы getpriority и setpriority позволяют процессу получать и изменять свое собственное или чужое значение nice.

Привилегированный процесс может изменить приоритет любой программы. Обычный процесс может изменить свой собственный приоритет или приоритет другой (целевой) программы, если она имеет такой же действующий идентификатор пользователя.

Стандартный алгоритм планирования ядра, как правило, обеспечивает достаточную производительность и отзывчивость для смеси интерактивных и фоновых процессов, которые обычно выполняются в системе. Однако приложения, работающие в режиме реального времени, имеют более высокие требования к планировщику. * Приложение реального времени должно гарантировать некое максимальное время реакции на внешний ввод.

В рамках любой политики планирования провесс с более высоким приоритетом всегда обгоняет менее приоритетные процессы в соперничестве за процессорное время.

Linux предоставляет 99 приоритетов реального времени.

При использовании политик реального времени, каждый приоритет хранит очередь выполняющихся процессов, и процесс, который будет выполнен следующим, берется из начала (непустой) очереди с самым высоким приоритетом.

Режим реального времени, который удовлетворяет всем требованиям, перечисленным выше, иногда называют жестким. Однако программный интерфейс POSIX для планирования процессов в режиме реального времени поддерживает не все из этих возможностей. В частности, он не позволяет приложениям гарантировать время реакции на ввод. Программный интерфейс POSIX предоставляет всего лишь так называемый мягкий режим реального времени, который позволяет управлять планированием выполнения процессов.

В рамках политики SCHED_RR процессы с одинаковым приоритетом выполняются в соответствии с циклическим разделением времени.

Политика SCHED_RR похожа на стандартный алгоритм планирования с циклическим разделением времени (SCHED_OTHER) в том смылсе, что она позволяет группе процессов с одинаковым приоритетом иметь общий доступ к процессору. Главной же отличительной чертов является наличие четких приоритетов, которые однозначно определеляют очередность выполнения процессов.

Системные вызовы sched_get_priority_max и sched_get_priority_min возвращают диапазон, доступный для политики планирования.

Системный вызов sched setscheduler изменяет политику планирования и приоритет процесса с идентификатором pid.

При успешном выполнении вызов sched_setscheduler перемещает процесс с идентификатором pid в конец очереди для соответствующего приоритета.

Политика планирования и приоритет наследуются потомком, созданным с помощью fork, и сохраняются на протяжении работы вызова exec.

Системные вызовы sched_getscheduler и sched_getparam позволяют получить сведения о политике планирования и приоритете процесса.

Процессы реального времени могут добровольно освободить ресурсы ЦПУ двумя способами: выполнив блокирующий системный вызов (например, чтение из терминала) или воспользовавшись вызовом sched_yield. Его использование вне политики реального времени не определено.

Смена процессоров при планировании в многопроцессорных системах отражается на производительности: чтобы загрузить линию данных в кеш нового ЦПУ, они сначала должны быть освобождены из кеша предыдущего процессора (см. планирование в многопроцессорных системах в трех элементах). Эта процедура увеличивает время выполнения. По этой причине ядро Linux (начиная с 2.6) пытается выполнять мягкую привязку процесса к ЦПУ, то есть по возможности работа процесса планируется на одном и том же процессоре.

Системный вызов sched_setaffinity привязывает к ЦПУ процесс, заданный с помощью аргумента pid. Получить маску родственных процессоров можно с помощью системного вызова sched_getaffinity.

Дочерний процесс, созданный с помощью вызова fork, наследует маску родственного процессора своего родителя и сохраняет ее на протяжении всего выполнения функции exec.

Маска родственного процессора позволяет привязать выполнение процесса к определенному набору доступных ЦПУ (если речь идет о многопроцессорной системе).

Системный вызов getrusage возвращает статистику, которая касается различных ресурсов системы, потребленных самим вызывающим процессом или всеми его потомками.

Файл /proc/PID/stat, доступный только в Linux, предоставляет некоторые сведения о потреблении ресурсов для любых процессов в системе.

Каждый процесс обладает набором ограничений, с помощью которых можно ограничить объем тех или иных системных ресурсов, которые тот может потребить.

Установить ограничения для процесса можно с помощью встроенной команды ulimit. Эти ограничения наследуются процессами, которые создаются командной оболочкой для выполнения пользовательских программ.

Смотри в Линукс файл /proc/PID/limits для просмотра всех ограничений на ресурсы любого процесса.

Сведения об ограничениях на ресурсы процесса можно получать и изменять с помощью системных вызовов getrlimit и setrlimit.

Только привилегированный процесс может изменить значение жесткого максимума (rlim_max) в обе стороны, однако обычные процессы могут его только уменьшать (без возможности отменить изменения).

Значения ограничений наследуются потомками через вызов fork и сохраняются на протяжении выполнения функции exec.

Ограничения на ресурсы относятся к отдельным процессам, однако в некоторых случаях они измеряются для всех процессов с одним и тем же реальным идентификатором пользователя.

Сегмент данных, принадлежащих процессу (сочетание сегментов с инициализированными/неинициализированные данными и кучей) - RLIMIT_DATA (максимальное отдаление крайней точки программы).

Демон - это процесс, обладающий следующими свойствами:
1) Имеет длинный жизненный цикл. Часто демоны создаются во время загрузки системы и работают до момента ее выключения.
2) Выполняются в фоновом режиме и не имеют контролирующего терминала.
3) Демоны создаются для выполнения специфических задач.

Многие стандартные демоны работают в качестве привилегированных процессов (EUID = 0).

В Linux некоторые демоны выполняются в качестве потоков ядра. Код таких процессов является частью ядра и обычно запускается во время загрузки системы. Команда ps выводит их названия в квадратных скобках.

Дочерний процесс вызывает setsid, чтобы начать новую сессию и разорвать любые связи с контролирующим терминалом (то есть уже даже вывод на терминал мы не можем осуществлять).

Только лидер сессии может стать управляющим процессом для терминала и вообще сделать открытый терминал управляющим.

/dev/null - это виртуальное устройство, которое всегда отклоняет записываемые в него данные.

Из того факта, что идентификаторы процесса и сессии не совпадают, можно сделать вывод, что процесс не является лидером сессии и не сможет установить соединение с контролирующим терминалом при открытии соответствующего устройства.

Демоны, у которых нет специальных завершащих скриптов, получают сигнал SIGTERM от процесса init. Через 5 секунд после SIGTERM процесс init отправляет сигнал SIGKILL (всем одновременно).

Конфигурационные файлы принято хранить в каталоге /etc или в одном из его подкаталогов, а журнач часто находится в /var/log.

Основной недостаток наличия отдельного журнального файла для каждого отдельного демона (с точки зрения системного администратор) заключается в сложности управдения журнальными файлами разных приложений и их мониторинге. Для решения этой проблемы была разработана система syslog.

Эта система предоставляет единый централизованный механизм, который позволяет любому приложению на компьютере записывать свои сообщения в журнал.

Система syslog состоит из двух основных компонентов: демона syslogd и библиотечной функции syslog(3).

Каждое сообщение, обработанное syslogd, имеет набор атрибутов, включая категорию, которая определяет тип программы, сгенерированное сообщение, и уровень, обозначающий значимость (приоритет) этого сообщения.

Впервые средства syslog были представлены в системе 4.2BSD, но теперь они доступны в большинстве реализаций UNIX.

Программный интерфейс syslog состоит из трех основных функций: openlog (необязательная), syslog, closelog.

Нельзя передавать вызову syslog произвольные строки, переданные пользователем.

Функция setlogmask устанавливает маску, которая фильтрует сообщения, записанные с помощью syslog.

При каждом изменении файла syslog.conf демону следует отправлять сигнал, чтобы он смог заново себя инициализировать.

Переоткрытие лог файлов по SIGHUP - это стандартный механизм для:
1) корректной работы logrotate
2) предотвращения потери логов
3) динамического обновления конфигурации

Система возможностей в Linux разбивает традиционную для UNIX структуру превилегий ("все или ничего") на отдельные сегменты, которые могут включаться и отключаться независимо друг от друга.

Использование возможностей позволяет программе выполнять только строго определенные привилегированные операции.

Вместо того, чтобы использовать сразу все привилегии администратора, выполняя проверки безопасности на уровне ядра, мы разделяем их на отдельные категории, которые называются возможностями.

Большую часть времени система возможностей Linux работает незаметно для пользователя. Дело в том, что в программе, которая расчитывает получить нулевой пользовательский идентификатор, выдается полный набор возможностей, даже если она о них не подозревает.

Каждый процесс имеет три набора возможностей: разрешенные, действующие и наследуемые.

Классификация IPC механизмов: взаимодействие, синхронизация, сигналы.

Похожие возможности, предоставляемые некоторыми IPC механизмами связаны с тем, что: похожие механизмы эволюционировали параллельно в разных вариатнах UNIX и позже были перенесены на другие системы; некоторые механизмы были разработаны для устранения недостатков более ранних аналогов.

Средства взаимодействия можно разделить на две категории: средства передачи данных, разделяемая память.

Средства взаимодействия также могут использоваться для синхронизации. В целом синхронизация может быть выполнена за счет любого механизма передачи данных.

Чтобы получить доступ к IPC объекту, у процесса должна быть возможность его идентифицировать; после "открытия" объекта процесс должен использовать некий дескриптор, который на него ссылается.

Из всех IPC-механизмов, представленных на рис. 43.1, только сокеты позволяют процессам взаимодействовать по сети. Они обычно применяются в доменах: либо в UNIX, обеспечивающем общение между процессами в рамках одной системы, либо в интернет домене, который дает возможность процессам, находящимся на разных компьютерах, взаимодействовать по сети TCP/IP.

Современные реализации UNIX поддерживают большинство IPC-механизмов, представленных на рис. 43.1. Однако механизмы, относящиеся к стандарту POSIX, распространены не так широко, как их аналоги из мира System V; особенно это касается старых систем. Поэтому с точки зрения портируемости IPC-механизмы из System V могут быть более предпочтительными, чем их POSIX-альтернативы.

Несколько IPC механизмов доступны только связанным процессам. Эта связь присутствует на уровне вызова fork. Чтобы два процесса получили доступ к объекту, один из них должен создать данный объект и затем вызвать fork. После этого дочерний процесс наследует дескриптор, ссылающийся на объект, что позволяет процессу разделить его со своим родителем.

Термин "сохраняемость" (устойчивость) относится к продолжительности существования IPC объекта. С этой точки зрения объекты можно разделить на 3 категории: сохранямость на уровне процесса, сохраняемость на уровне ядра, сохраняемость на уровне файловой системы.

В некоторых ситуациях разные IPC-механизмы могут демонстрировать существенные различия в производительности.

Если производительность IPC играет решающую роль, единственный способ выбрать подходящий механизм - провести измерения в среде, которая соответствует целевой системе. Для этого можно даже написать абстрактный программный слой, инкапсулирующий подробности реализации IPC-механизма, и затем провести тестирование производительности с помощью разных средств межпроцессного взаимодействия.

Каналы являются наиболее старым средством межпроцессного взаимодействия в UNIX системах (начало 1970-ых). Этот механизм предоставляет элегантное решение распространенной задачи: имея два процесса, выполняющие две разные программы (команды), нужно сделать так, чтобы командная оболочка направила вывод одного из них в ввод другого.

Когда мы говорим, что канал представляет собой поток байтов, мы имеем ввиду следующее: при его использьзовании не существует понятия сообщений или их границ.

Произвольный доступ к содержимому канала с помощью вызова lseek невозможен.

Данные канала могут перемещаться только в одном направлении.

Если несколько процессов выполняют запись в один и тот же канал, их данные никогда не перемешаются, есои ни один из них не стане записывать более чем PIPE_BUF байт за раз.

Если записываемый в канал блок данных превышает PIPE_BUF байт, ядро может разбить его на более мелкие части и передавать их по мере того, как считывающий процесс удаляет их из канала (вызов write блокируется, пока в канал не будут записаны все данные).

Канал - это всего лишь буфер, находящийся в памяти ядра.

В общем случае приложению не нужно знать точную вместимость канала. Если нужно предотвратить блокировку записывающих процессов, то процессы, считывающие данные, должны изымать содержимое канала по мере его поступления.

Увеличение размера буфера продиктовано требованиями к производительности: каждый раз, когда записывающий процесс заполняет канал, ядро вынуждено переключать контекст, чтобы считывающий процесс мог извлечь данные из канала. Чем больше буфер, тем реже приходиться переключать контекст.

Системный вызов pipe создает новый канал.

Как и в случае с любыми другими дескрипторами, для выполнения ввода\вывода в контексте канала можно использовать системные вызовы read и write.

для работы с каналом также можно применять функции стандартного ввода\ввода, предварительно получив файловый поток из одного из дескрипторов в массиве filedes, задействуя вызов fdopen.

Теоретически в канал может записывать неограниченное количество процессов, но обычно применяться только один процесс.

До сих пор мы обсуждали канали, предназначенные для взаимодействия родительского и дочернего процессов. Однако они дают возможность взаимодействовать любым двум (и более) родственным процессам, общий предок которых создал канал до выполнения цепочки вызовов fork (вот что мы имели ввиду, когда упоминали родственные процессы в начале этой главы). Например, канал позволяет организовать взаимодействие процесса и его внука.

Обычно каналы используются для взаимодействия процессов одного уровня: родитель открывает канал и создает двух потомков. Именно это и делает командная оболочка, когда формирует конвейер.

Закрытие неиспользуемых дескрипторов канала требуется не только для того, чтобы не дать процессу превысить ограничение на открытие дескрипторы; это необходимое условие корректной работы каналов.

Процесс, читающий из канала, закрывает его записывающий дескриптор, чтобы иметь вохможность обнаружить конец файла когда другой процесс закончит вывод и закроет свой дескриптор. Если этого не сделать, читающий процесс не сможет понять когда другой процесс завершит свой ввод. Вместо этого операция read будет заблокирована в ожидании новой информации, поскольку ядро знает: у данного канала остался по крайней мере один записывающий дескриптор.

Тот факт, что дескриптор открыт самим считывающим процессов, не имеет никакого значения; теоретически этот процесс может записывать в канал, несмотря на то что он заблокирован при попытке чтения. Например, операция read может быть прервана обработчиком сигнала, который записывает данные в канал.

Записывающий процесс закрывает считывающий дескриптор канала по другой причине. Если попытаться записать в канал, на другом конце которого нет открытого дескриптора, ядро пошлет сигнал SIGPIPE. По умолчанию это приводит к завершению процесса, хотя он может перехватить его или проигнорировать - в таком случае запись в канал завершится ошибкой EPIPE (канал поврежден). Получение сигнала SIGPIPE или ошибки EPIPE позволяет узнать состояние канала, поэтому неиспользуемый считывающий дескриптор следует закрывать.

Еще одна причина для закрытия неиспользуемых дескрипторов состоит в том, что канал можно уничтожить и освободить его ресурсы только после того, как будут закрыты все дескрипторы во всех процессах, ссылающихся на данный канал. В этот момент любые данные, которые в нем еще оставались, теряются.

Синхронизация с помощью каналов имеет преимущество по сравнению с ранее представленным примером, в котором для этого используются сигналы: она позволяет координировать действия одного процесса с множеством других (родственных) процессов.

Нужно внимательно следить за тем, действительно ли оболочка открывает три дескриптора перед работой программы.

Каналы часто используют для выполнения консольных команд - в частности, для считывания их вывода или передачи им какого нибудь ввода. Для упрощения этой задачи предусмотрены функции popen и pclose.

С точки зрения семантики очередь FIFO похожа на канал. Ее принципиальное отличие заключается в том, что у нее есть имя в рамках файловой системы и ее можно открывать так же, как обычный файл. Это позволяет использовать очереди FIFO для взаимодействия процессов, не имеющий отношения друг к другу. Такие очереди иногда называют именованными каналами.

Как и в случае с каналами, данные внутри очереди FIFO теряются при закрытии последнего дескриптора, который на нее ссылается.

mkfifo.

Изначально очереди фифо создавались с помощью системного вызова mknod, который позволяет создавать различные виды файлов, включая файлы устройств. В стандарте POSIX.1-1990 появился более простой, хотя и менее универсальный программный интерфейс, mkfifo. В большинстве UNIX систем он реализован в виде обертки вокруг mknod.

Новую очередь FIFO может открыть любой процесс, имеющий соответствующие права доступа.

Открытие очереди FIFO синхронизирует считывающий и записывающий процессы путем блокировки.

Если нужно предотвратить блокировку при открытии очереди FIFO, то функции open можно передать стандартизированный флаг O_NONBLOCK, предназначенный специально для этого.

Очередь FIFO позволяет создать внутри конвейера ответвление, благодаря которому копия вывода процесса может быть передана еще одному адресату. Для этого необходимо применить команду tee.

Данные внутри каналов и очередей FIFO представляют собой потоки байтов; границ между отдельными сообщениями не существует.

Имейте в виду, что в каждой из приведенных методик общая длина сообщения не должна превышать PIPE_BUF байт, иначе оно может быть разбито ядром на несколько частей и перемешано с сообщениями от других отправителей.

В листинге 44.7 представлен пример итерационного сервера, который последовательно считывает и обрабатывает запросы каждого из клиентов. Модель данного сервера подходит в ситуации, когда клиентские запросы можно быстро обработать и вернуть ответ, чтобы не задерживать других клиентов. Альтернативой ему является параллельный сервер, обрабатывающий каждый клиентский запрос в отдельном дочернем процессе (или потоке).

Вместо установки обработчика выхода для удаления клиентской очереди можно было бы вызвать unlink сразу после открытия клиентской очереди. В этом случае файл очереди продолжал бы существовать до тех пор, пока на него ссылаются какие либо дескрипторы процесса.

Если другой конец очереди уже открыт, то флаг O_NONBLOCK никак не влияет на вызов open - очередь сразу же успешно открывается, как обычно. Действие этого флага проявляется только в случае, если другой конец очереди FIFO еще не открыт, и зависит оно от того, какой именно конец открывается - считывающий или записывающий.

Использование влага O_NONBLOCK при открытии очереди FIFO служит двум основным целям:
1) позволяет одному процессу открыть оба конца очереди.
2) предотвращает взаимную блокировку процессов, которые открывают две очереди FIFO.

Этот флаг способен влиять на семантику не только вызова open, но и последующих операций read и write, так как продолжает действовать для открытого файлового дескриптора.

Для включения\выключения этого флага можно воспользоваться вызовом fcntl.

Флаг O_NONBLOCK приводит к сбою записи в канал или очередь FIFO (EAGAIN) в любой ситуации, в которой немедленная передача данных невозможна.

Каналы стали первым средством межпроцессоного взаимодействия в UNIX-системах.

Системный вызов mmap создает в виртуальном адресном пространстве процесса новое отображение в память. Отображения бывают двух видов: отображение файла, анонимное отображение.

Участок памяти в отображении одного процесса можно разделять с отображением другого процесса (то есть записи таблицы со страницами каждого из процессов будут указывать на одни и те же страницы физической памяти).

Дочерний процесс, созданный с помощью fork, наследует копии родительских отображений.

Видимость изменений в отображении для родительского и дочерних процессов зависит от того, является ли отображение приватным или разделяемым.

Разделяемое файловое отображение позволяет неродственным процессам разделять один и тот же участок памяти для обеспечения (быстрого) межпроцессного взаимодействия.

Отображения теряются, когда процесс выполняет вызов exec.

В Linux информация обо всех отображениях процесса доступна в специальном файле вида /proc/PID/maps.

Страницы, защищенные флагом PROT_NONE, среди прочего используются в начале и конце участка памяти, выделяемого процессом.

Сведения о защите хранятся в таблицах виртуальной памяти, выделяемых для каждого отдельного процесса.

Системный вызов munmap выполняет действие, обратное mmap, - удаляет отображение из виртуального адресного пространства вызывающего процесса.

Во время удаления отображения ядро уничтожает все блокировки памяти, удерживаемые процессом в заданном диапазоне адресов.

Вызов exec (или завершение) автоматически удаляет все его отображения.

Чтобы записать содержимое отображения обратно в исходный файл, перед удалением следует сделать вызов msync.

Файл, на который ссылается дескриптор fd, должен быть открыт с правами доступа, соответствующими значениям аргументов prot и flags.

Разделяемые файловые отображения используются для двух задач: отображения ввода\вывода в память и межпроцессного взаимодействия.

Поскольку содержимое разделямого файлового отображения берется из файла, в который  возвращаются любые изменения, внесенные в само отображение, можно выполнять файловый ввод\вывод, просто работая с байтами памяти, - все изменения будут автоматически применены ядром к исходному файла. Такой подход называется отображением ввода\вывода в память.

Выгода от улучшенной производительности ввода\вывода в большинстве случаев проявляется при выполнении множества операций произвольного доступа к большому файлу. При последовательной доступе вызов mmap почти (или совсем) не имеет существенных преимуществ по сравнению с операциями read и write, при условии, что используется буфер достаточных размеров, который позволяет избежать большого количетства системных вызовов для ввода\вывода.

Попытки доступа за пределы отображения приводят к генерации сигнала SIGSEGV.

Если отображение выходит за пределы отображаемого файла, оставшиеся байты заполняются нулями (это требование стандарта SUSv3).

Если отображение содержит страницы, выходящие за пределы отображенного участка, попытки получения доступа к адресам внутри указанных страниц приводят к генерированию сигнала SIGBUS.

Системный вызов msync предоставляет приложению возможность самостоятельно синхронизировать разделяемое отображение с отображенны файлом.

Анонимным называют отображение, которое не связано с исходным файлом.

Анонимные отображения типа MAP_PRIVATE служат для выделения блоков памяти, принадлежащих только одному процессу и заполненных нулями.

Анонимные отображения типа MAP_SHARED позволяют родственныи процессам (например, родителю и потомку) работать с одним и тем же участком памяти, не используя связанный с ним отображенный файл.

В большинстве UNIX-систем нельзя изменить местоположение и размер существующего отображения. Однако Linux предоставляет (недоступный в других реализациях) вызов mremap, который делает возможными такие изменения.

Системный вызов mprotect изменяет защиту страниц виртуальной памяти. Защита распространяется на целые страницы.

Режим сна в настольных и переносных компьютерах сохраняет копию физической памяти на диск вне зависиомти от блокировки памяти.

Блокировка применяется постранично, поскольку единицей управления виртуальной памятью является страница.

Для блокировки и разблокировки участков памяти процесс может использовать вызовы mlock и munlock.

Чтобы узнать, сколько всего памяти заблокировал текущий процесс, можно прочитать поле VmLck в файле /proc/PID/status.

Блокировки могут удаляться также автоматически (не только благодаря вызову munlock). Это происходит в следующих ситуациях:
1. при завершении процесса
2. при удалении заблокированных страниц из отображения с помощью вызова munmap.
3. 0_0

Блокировки памяти не наследуются потомком, созданным путем вызова fork, и не сохраняются на протяжении работы exec.

Для блокировки и разблокировки всей памяти процесса можно использовать вызовы mlockall и munlockall.

Системный вызов madvise служит для улучшения производительности программы путем информирования ядра о том, как именно вызывающий процесс (скорее всего) будет применять страницы в памяти в указанном диапазоне.

Стандарт POSIX.1b содержит ряд расширений реального времени, которые формируют набор IPC-механизмов (одной из целей создателей данного стандарта было разработать средства межпроцессного взаимодействия, лишенные недостатков аналогичных механизмов из состава System V). В совокупности эти механизмы называются POSIX IPC.

Единственным портируемым средством идентификации POSIX IPC объекта, предусмотренным стандартом SUSv3, является обращение по имени, которое начинается со слеша.

Таким образом, в портируемых приложениях процедуру генерирования имен IPC-объектов следует выносить в отдельные функции или заголовочные файлы, которые можно адаптировать для целевой системы.

Дескриптор, возвращаемый IPC-вызовом open, аналогичен файловому дескриптору, который возвращается традиционным системным вызовом open, - он используется в последующих операциях с заданным объектом.

IPC-объекты автоматически закрываются, когда процесс завершает свою работу или выполняет вызов exec.

IPC-объекты имеют такую же маску с правами доступа, как и файлы, поэтому обращение к ним и к файлам ограничивается по одному и тому же принципу. Различие только в том, что в случае объектов POSIX IPC права на выполненеи не имеют никакого смысла.

Как и в System V, объекты POSIX IPC хранятся на уровне ядра. После создания они продолжают существовать, пока не будут удалены или системы не будет выключена.

В Linux объекты POSIX IPC находятся в виртуальных файловых системах, подключенных к каталогам, для которых установлен закрепляющий бит.

В Linux программы, применяющие механизмы POSIX IPC, должны быть скомпонованы с библиотекой реального времени под названием librt.

POSIX IPC - это собирательное название трех IPC-механизмов: очередей сообщений, семафоров и разделяемой памяти.

Интерфейс для работы с очередями POSIX сообщений обладает двумя специфическими свойствами:
1) каждая очередь сообщений имеет определенный набор атрибутов.
2) возможность регистрации оповещения.

По аналогии с обычными файловыми дескрипторами после вызова fork дочерний процесс получает копии дескрипторов очередей сообщений, открытых его родителем. Потомок не наследует от родителя подписки на уведомления о сообщениях.

Интересности происходят с вызовом exec. Когда процесс выполняет вызов exec или завершается, все дескрипторы открытых очередей сообщений закрываются.

Связь между дескрипторами и очередями сообщений. Данная связь аналогична отношениям между файловым дескриптором и самим открытым файлом. Дескриптор очереди ообщений принадлежит конкретному процессу и ссылается на запись в общесистемной таблице открытых дескрипторов этого типа; данная запись в свою очередь указывает на объект очереди.

Атрибуты mq_maxmsg и mq_msgsize инициализируются во время создания очереди и больше не могут быть изменены.

Если attrp = NULL, то очередь сообщений создается с атрибутами, применяемыми по умолчанию в текущей системе.

Функция mq_getattr возвращает структуру mq_attr, содержащую сведения об атрибутах очереди сообщений и саму очередь, связанную с дескриптором mqdes.

Функция mq_setattr устанавливает атрибуты очереди сообщений, связанной с дескриптором mqdes, и в случае необходимости возвращает сведения о самой очереди.

Функция mq_send отправляет сообщение из буфера msg_ptr в очередь сообщений, на которую ссылается дескриптор mqdes.

Сообщения в очереди размещаются в порядке убывания приоритета. Когда в очередь добавляется новое сообщение, оно занимает место сразу за всеми сообщениями одного с ним приоритета.

Стандарт SUSv3 позволяет реализации определить максимально возможный приоритет; это делается с помощью константы MQ_PRIO_MAX.

Функция mq_recieve удаляет из очереди, куда ссылается дескриптор mqdes, самое старое сообщение с наивысшим приоритетом.

При работе с очередями сообщений мы не увидим символ конца файла при отсутствии записывающих процессов, как это происходит при использовании каналов.

Функции mq_timedsend и mq_timedrecieve являются прямыми аналогами sq_send и mq_recieve, но с одним отличием: если операция не может быть выполнена немедленно и если среди атрибутов сообщения не указан флаг O_NONBLOCK, аргумент abs_timeout определяет продолжительности блокирования вызова.

Особенность, которая отличает очереди сообщений POSIX от их аналогов из System V, состоит в возможности получать асинхронные оповещения о появлении в ранее пустой очереди нового сообщения (то есть очередь перестает быть пустой).

Оповещение можно получить либо в виде сигнала, либо путем вызова функции в отдельном потоке.

Функция mq_notify подписывает вызывающий процесс на оповещения.

Объекты POSIX IPC реализованы в виде файлов, которые хранятся в виртуальной файловой системе, и их можно выводить и удалять с помощью команд ls и rm. 
(в случае если соответствующая файловая система смонтирована с помощью команлы mount)

Можно вывести содержимое объектов в файловой системе очереди сообщений. Каждый из таких объектов (виртуальных файлов) содержит информацию о соответствующей очереди.

В Linux дескриптор очереди сообщений на самом деле является файловым дескриптором.

POSIX семафоры позволяют синхронизировать доступ к общим ресурсам  между разными процессами и потоками выполнения.

Стандартом SUSv3 предусмотрено два типа POSIX семафоров: именованные и анонимные.

POSIX семафор представляет собой целое число, которое не может опускаться ниже нуля.

Для работы с именованными семафорами предусмотрены следующие функции: sem_open, sem_post, sem_wait, sem_getvalue, sem_close, sem_unlink - удаляет имя семафора и делает его кандидатом на удаление; само удаление произойдет, когда семафор закроет все процессы.

В Linux именованные семафоры имеют вид небольших объектов разделяемой памяти POSIX, хранящихся в ФС tmpfs, подключенной к каталогу /dev/shm, а их имена выглядят как sem.name.

Именнованные семафоры в Linux поддерживаются с версии ядра 2.6.

Стандарт SUSv3 не описывает никаких флагов для аргумента oflag, определяющих режим доступа. Во многих системах, в том числе и в Linux, при открытии семафора по умолчанию используется режим доступа O_RDWR.

Потомок, созданный с помощью вызова fork, наследует ссылки на все именованные семафоры, открытые его родителем.

Когда процесс открывает именнованный семфор, между ними устанавливается связь на уровне записи, которая создается системой. Функция sem_close удаляет эту связь (то есть закрывает семафор). Когда процесс завершается или выполняет вызов exec, открытые им именованные самафоры автоматически закрываются.

Функция sem_unlink удаляет семафор с именем name и делает его кандидатом на удаление, которое происходит, когда все процессы перестают его использовать.

При блокировке в вызове sem_wait несколько процессов (или потоков) в случае использования стандартной циклической политики разделения времени невозможно определить, какой из них возобновит работу и выполнит декрементацию (POSIX семафоры являются лишь средством синхронизации; они не предназначены для создания очередей).

Анонимные семафоры (основанные на памяти) представляют собой переменные типа sem_t, которые хранятся в памяти, выделенной приложением.
