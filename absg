Quoting a variable preserves whitespace

Variable referencing disables (escaped) by single quotes, which causes the "$" t
o be interpreted literally

Un initialized variable has a "null" value -- no assigned value at all (not zero
!)

An uninitialized variable has no value, however it evaluates as 0 in ar arithmet
ic operation

The special variables $* and $@ denote all the positional parameters

shift operation is not a parameter *copy*, but a *move*

A character is "special" if it has an interpretation other than its literal mean
ing

Within single quotes, `every special character except ' gets interpreted literal
ly

Escaping is a method of quoting single characters

Elements of a string assigned to a variable may be escaped, but the escape chara
cter alone may not be assigned to a variable

An escape at the end of a line escapes the newline character

Command [ is a synonym for test, and a builtin for efficiency reasons

Note that the exit status of an arithmetic expression is not an error value

An if can test any command, not just conditions enclosed within brackets

Keywords (or commands) begin statements, and before a new statement on the same 
line begins, the old one must terminate

[ does not call /usr/bin/[, which is linked to /usr/bin/test (like bash builtin 
test does not call /usr/bin/test binary

The main reason why there is an external binary test is programs which need to e
xecute a test and which is not a shell or a shell with no such a builtin command

No filename expansion or word splitting takes place between [[ and ]], but there
 is parameter expansion and command substitution

Keywords (or commands) begin statements, and before a new statement on the same 
line begins, the old one must terminate

The (()) construct expands and evaluates an arithmetic expression

Integer and string comparison use a different set of operators

Bash permits integer operations and comparsions on variables whose value consist
s of all-integer characters

The [ ... ] operator alone detects whether the string is null. However it is a g
ood practice to quote it (if [ "$string" ])

Apparently && and || are "short-circuit" while -a and -o do not

Bash does not understand floating point arithmetic. It treats numbers containing
 a decimal point as strings

Bash tests the exit status of each statement linked with a logical operator

The -a and -o options provide an alternative compound condition test

A shell script interprets a number as decimal (base 10), unless that number has 
a special prefix or notation

Similar to the let command, the ((...)) construct permits arithmetic expansion a
nd evaluation. This construct is also a mechanism for allowing C-style manipulat
ion of variables in Bash

Evaluation of "condition1" and "condition2" happens before ANDing them. Why? Bec
ause the AND (-a) has a lower precedence than the -n and -gt operators

Builtin variables are variables affecting bash script behavior. This does not me
an the variable changes the script's logic (like an if statement would). Instead
, these built-in variables changes how Bash itself processes and executes the sc
ript. They may configurate some behaviour, give some information and etc

When the script exits, this restores the original $PATH (A child process, such a
s a script, may not change the environment of the parent process, the shell)

$REPLY holds the value of last "read" if and only if no variable supplied

The $@ and $* parameters differ only when between double quotes

The declare or typeset builtins, which are exact synonyms, permit modifying the 
properties of variables. This is a very weak form of typing

Bash supports a surprising number of string manipulation operations

Only ${} form can be used for concatenating variables with strings

${parameter-default} and ${parameter:-default} are almost equivalent. The extra 
: makes a difference only when parameter has been declared, but is null

The default parameter construct finds use in providing "missing" command-line ar
guments in scripts

Only the final condition in while loop determines when the loop terminates

The break command may optionally take a parameter. A plain break terminates only
 the innermost loop in which it is embedded, but break N breaks out of N levels 
of loop. Continue command has the same mechanism

Command substitution reassigns the output of a command or even multiple commands
; it literally plugs the command output into another context

$() is an alternative form of ``

Command substitution invokes a subshell

Command substitution permits setting a variable to the output of a loop

The use of backticks (backquotes) in arithmetic expansion has been superseded by
 double parantheses -- ((...)) and $((...)) -- and also by the very convenient l
et construction

$((EXPRESSION)) is arithmetic expansion. Not to be confused with command substit
ution

((...)) construction is used for evaluating expression, but it does not return i
t's value. It is used as a command and return return code (0,1)

A builtin is a command contained within the Bash toolset, literally built in

Generally, a Bash builtin does not fork a subprocess when it executes within a s
cript

A builtin may be a synonym to a system command of the same name, but Bash reimpl
ements it internally

Data entry for read command terminates with the first <ENTER>

A while loop may have its stdin redirected to a file by a < at its end

Piping output to read, using echo to set variables will fail

The familiar cd change directory command finds use in scripts where execution of
 a command requires being in a specified directory

At the script start, directory stack holds $PWD

Let command with quotes permits using spaces

Let command permits C-style operators just as the (( ... )) double-parantheses c
onstruct does

The set command changes the value of internal script variables / options

The unset command deletes a shell variable, effectively setting it to null. Note
 that this command does not affect positional parameters

In most contexts, an undeclared variable and one that has been unset are equival
ent

The export command makes available variables to all FUTURE child processes of th
e running script or shell via modifying the environment (see man 2 fork)

The declare and typeset commands specify and\or restrict properties of variables

An option is an argument that acts as a flag, switching script behaviors on or o
ff

Within a script, a source file-name loads the file file-name

. $0 reads and executes commands from $0 in current context (loop); ./$0 execute
s a separate program (recursion)

Normally, when the shell encounters a command, it forks off a child process to a
ctually execute the command

shopt command permits changing shell options on the fly

help. Gets a short usage summary of a shell builtin. This is the counterpart to 
whatis, but for builtins

Jobs are maintained by the current shell, whereas processes are maintained by th
e system

The killall command kills a running process by name, rather that by process ID (
PID)

A filter is a command that transforms its input for processing

"--" - the end of options flag

Dotfiles cannot be deleted by an accidental rm -rf *

Unlike a hard link, a symbolic (soft) link can refer to a directory

Every filename has an inode, a record that holds its physical address info

touch - Utility for updating access/modification times of a file to a current sy
stem time or other specified time, but also useful for creating a new file

uniq - This filter removes duplicate lines from a sorted file

cut - A tool for extracting fields from files

grep - A multi-purpose file search tool that uses Regular Expressions

tr - A character translation filter

The cat "$@" construct permits input either from stdin or from files

nl - A line numbering filter

ar - A creation and manipulation utility for archives, mainly used for binary ob
ject file libraries

file - A utility for identifying file types

A checksum is a number mathematically calculated from the contents of a file, fo
r the purpose of checking its integrity

Bash can't handle floating point calculations, and it lacks operators for certai
n important mathematical functions. Fortunately, bc gallops to the rescue

tee utility is a redirection operator, but with a difference

The id command lists the real and effective user IDs and the group IDs of the cu
rrent user associated with the current process

The file /etc/sudoers holds the names of users permitted to invoke sudo

passwd command can be used to set, change, manage a user's password

uname can be used to output system specifications (OS, kernel version, etc..) to
 stdout

pgrep, pkill commands allow to combine the ps command with grep or kill

fuser. Identifies the processes (by PID) that are accessing a given file, set of
 files, or directory

Before physically removing a previously mounted floppy or CDROM disk, the device
 must be unmounted, else filesystem corruption may result

Regular Expressions are sets of characters and\or metacharacters that match (or 
specify) patterns

The only way to be certain that a particular RE works is to test it

Question sign matches zero or one of the previous RE

POSIX Character Classes is an alternate method of specifying a range of characte
rs to match

Bash itself cannot recognize Regular Expressions. Inside scripts, it is commands
 and utilities -- such as sed and awk -- that interpret RE's. Bash does carry ou
t filename expansion -- a process knows as globbing -- but this does not use the
 standard RE set. Instead, globbing recognizes and expands wildcards

Bash performs filename expansion on unquoted command-line arguments

Here document has the effect of redirecting the output of a command block into t
he stdin of the program or command

Use ': > filename' instead '> filename', because the second construction does no
t work with some shells. '.' serves as a dummy placeholder, producing no output

Operator M>&N redirects one file descriptor to another

"ls nonexist &> file" works the same as "ls nonexist > file 2>&1"

0< FILENAME
 < FILENAME
	Accept input from a file (reads it automatically). Companion command to 
">", and often used in combination with it

"command < input-file > output" file is the exact equivalent of "< input -file c
ommand > output-file", although this is non-standard

Shell handles redirection from left to right. That's important!

An "exec <filename" command redirects stdin to a file (see bash-builtins(7))

Bash (but not sh) has arrays support

Bash supports only one-dimentional arrays, though a little trickery permits simu
lating multi-dimensional ones

Indirect variable references (value of the value). The actual notation os \$$var
, usually preceded by eval (and sometimes echo). A more straightforward method i
s the ${!var} notation

Bash does not support pointer arithmetic

The /proc directory is actually a pseudo-filesystem. The files in /proc mirror c
urrently running system and kernel processes and contain information and statist
ics about them

When a command sequence gets too complex, look for a shortcut

Echo statements are useful for seeing whether what you expect is actually what y
ou get

Correct methods of deleting filenames containing spaces:
rm *\ *
rm *" "*
rm *' '*
# Thank you, S.C.

trap builtin: Specifies an action on receipt of a signal; also useful for debugg
ing

Options are settings that change shell and/or script behavior

The DEBUG argument to trap causes a specified action to execute after every comm
and in a script

trap '' SIGNAL disables SIGNAL for the remainder of the script. trap SIGNAL rest
ores the functioning of SIGNAL once more.

Variable names starting with a digit are reserved by the shell

$_ is a special variable set to last arg of last command, so it's name is also r
eserved

Piping echo output to a read may produce unexpected results. In this scenario, t
he read acts as if it were running in a subshell

The set command enables options within a script

All caps used for a script constant

Uppercase for an errorcode, and name prefixed with E_

Uppercase for an environmental variable

By convention, a command reads its input from fd 0 (stdin), prints normal output
 to fd 1 (stdout), and error output to fd 2 (stderr). If one of those three fd's
 is not open, you may encounter problems

Bash history commands: history, fc


